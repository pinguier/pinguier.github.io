<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单调栈的应用1</title>
    <url>/2024/10/28/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A81/</url>
    <content><![CDATA[<h3 id="单调栈的定义："><a href="#单调栈的定义：" class="headerlink" title="单调栈的定义："></a>单调栈的定义：</h3><blockquote>
<p>单调栈是栈的一中特殊形式，在栈中的元素必须满足单调性（一定是单调上升或单调下降等等的规律）。</p>
</blockquote>
<hr>
<h3 id="单调栈的性质："><a href="#单调栈的性质：" class="headerlink" title="单调栈的性质："></a>单调栈的性质：</h3><ul>
<li><h4 id="单调栈解决的问题"><a href="#单调栈解决的问题" class="headerlink" title="单调栈解决的问题"></a>单调栈解决的问题</h4></li>
</ul>
<blockquote>
<p>单调栈解决的常见问题：给定一个序列，求每个位置左边，离他最近且小于他的数的位置。<br>我们可以这样理解单调栈：<br>既然我们必须让元素满足单调性，那么每次插入就和栈顶作比较。<br>如果不满足某些性质，直接弹出栈顶，直到栈为空或满足该性质插入这个元素。</p>
</blockquote>
<hr>
<ul>
<li><h4 id="如何维护一个单调栈"><a href="#如何维护一个单调栈" class="headerlink" title="如何维护一个单调栈"></a>如何维护一个单调栈</h4></li>
</ul>
<blockquote>
<p>单调递增栈：在保持栈内元素单调递增的前提下（如果栈顶元素大于要入栈的元素，将将其弹出），将新元素入栈。<br>单调递减栈：在保持栈内元素单调递减的前提下（如果栈顶元素小于要入栈的元素，则将其弹出），将新元素入栈。</p>
</blockquote>
<hr>
<ul>
<li><h4 id="单调栈的规律"><a href="#单调栈的规律" class="headerlink" title="单调栈的规律"></a>单调栈的规律</h4></li>
</ul>
<p><img src="/images/%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg"><br><img src="/images/%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg"></p>
<hr>
<h3 id="单调栈练习题汇总"><a href="#单调栈练习题汇总" class="headerlink" title="单调栈练习题汇总"></a>单调栈练习题汇总</h3><ul>
<li><strong>已解决</strong><blockquote>
<p>1 <a href="https://www.acwing.com/problem/content/832/">模拟单调栈</a><br>2 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">leetocde T84柱形图中的最大矩形</a><br>3 <a href="https://leetcode.cn/problems/maximal-rectangle/description/">leetcode T85 最大矩形面积</a></p>
</blockquote>
</li>
<li>未完待续</li>
</ul>
<hr>
<h3 id="模拟单调栈"><a href="#模拟单调栈" class="headerlink" title="模拟单调栈"></a>模拟单调栈</h3><ul>
<li>分析<blockquote>
<p>本题是单调栈的模板题，可以用数组模拟单调栈，但是我个人更喜欢用Stack集合调用API的方式。</p>
</blockquote>
</li>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) q[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; q[stk.peek()] &gt;= q[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) System.out.print(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(q[stk.peek()] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="柱形图中的最大矩形"><a href="#柱形图中的最大矩形" class="headerlink" title="柱形图中的最大矩形"></a>柱形图中的最大矩形</h3><ul>
<li>题目分析：<blockquote>
<p>本题中在该柱状图中，求能够勾勒出来的矩形的最大面积这个问题，可以模拟样例，想一想如何解决这个面积问题？<br>首先对于面积，需要底×高，高度跟每个柱子的高度有关，底和对应柱子的下标有关系。正确的思路是枚举每个柱子的高度，以这个高度向左右两边进行扩展，如果能找到当前柱子左右两边的离他最近且小于他的高度的柱子,那么这个柱子所能构成的最大矩形面积就是用当前的柱子的高度<code>h[i] * (right[i] - left[i] - 1) </code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>为什么要减1？</strong><br><code>right[i] - left[i]</code>：这是从<code> left[i]</code> 到 <code>right[i]</code> 之间的距离，但这包括了<code>left[i]</code>和 <code>right[i]</code> 本身。<br>我们真正关心的是柱子<code> i</code> 左边和右边，第一个小于它的柱子之间的距离，所以不包括 <code>left[i]</code> 和<code> right[i]</code>，而是 <code>left[i]</code> 和<code> right[i]</code> 之间的元素个数。因此，要在 <code>right[i] - left[i]</code> 的基础上再减去 1。<br><strong>举例：</strong><br>假设 <code>heights = [2, 1, 5, 6, 2, 3]</code>，我们考察柱子<code>i = 2</code>(即高度为 5 的柱子):<br><code>left[2] = 1</code>：在 <code>heights[2]</code> 左边，第一个小于 5 的柱子在索引 1。<br><code>right[2] = 4</code>：在 <code>heights[2]</code> 右边，第一个小于 5 的柱子在索引 4。<br>所以 <code>right[2]</code> -<code> left[2]</code> - 1 &#x3D; 4 - 1 - 1 &#x3D; 2。<br>这表示柱子 i &#x3D; 2 的宽度为 2（包括自己）时，高度为 5 的矩形面积最大。因此，面积为<code> heights[2] * (right[2] - left[2] - 1) = 5 * 2 = 10</code>。</p>
</blockquote>
<ul>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[stk.peek()] &gt;= heights[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) left[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护当前元素的右边比自己小的最近的数的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[stk.peek()] &gt;= heights[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) right[i] = n;</span><br><span class="line">            <span class="keyword">else</span> right[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="最大矩形的面积"><a href="#最大矩形的面积" class="headerlink" title="最大矩形的面积"></a>最大矩形的面积</h3><p><img src="/images/leetcode85.jpg" alt="最大的矩形面积示例"></p>
<ul>
<li><strong>分析</strong><blockquote>
<p>本题拿过来乍一看感觉非常困难，但是仔细想想，还是单调栈的应用。怎么把矩形面积和单调栈练习在一起呢？<br>通过上面柱形图中的最大矩形面积这题可以得知，我们现在可以用单调栈的方法解决一个维度的面积，本题中的矩阵面积，不也可以想象成是把某一行当作基底，往上看连续的1个数就代表了柱形的高度。因此本题可以转换为，按行枚举每一行的柱子，然后按照上题的思路求出每一行的最大面积，然后扩展到二维。因此本题与上题的差别就在于，怎么枚举每一行的柱子高度，这就需要预处理出来<code>h[i][j]</code>。对于<code>h[i][j]</code>的表示和计算，我认为类似一个<code>dp</code>问题.</p>
</blockquote>
</li>
</ul>
<p><strong>状态表示:</strong></p>
<blockquote>
<ul>
<li><code>h[i,j]</code>表示所有以<code>(i,j)</code>为终点，能往上延伸的最大高度。</li>
</ul>
</blockquote>
<p><strong>状态计算:</strong></p>
<blockquote>
<ul>
<li>若当前位置是0，则<code>h[i,j] = 0</code></li>
<li>若当前位置是1，则<code>h[i,j] = 1 + h[i,j]</code></li>
</ul>
</blockquote>
<ul>
<li>代码 时间复杂度 : O($n^2$)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] h = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 预处理出来矩形的高度 dp的思想</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>) h[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> h[i][j] = <span class="number">1</span> + h[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按行枚举基准线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) ans = Math.max(ans, getReactangeArea(h[i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getReactangeArea</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[ n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; h[stk.peek()] &gt;= h[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) left[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; h[stk.peek()] &gt;= h[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) right[i] = n ;</span><br><span class="line">            <span class="keyword">else</span> right[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) res = Math.max(res, (right[i] - left[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底解决区间dp问题</title>
    <url>/2024/10/30/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4dp%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="区间dp的理解"><a href="#区间dp的理解" class="headerlink" title="区间dp的理解"></a>区间dp的理解</h3><blockquote>
<p>对于一段区间的元素进行操作，操作必须是连续的，求解，在这段区间上的属性(<strong>Min</strong> &#x2F; Max),考虑动态规划的考虑方式。</p>
</blockquote>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><blockquote>
<p>所有的区间dp问题枚举时，<strong>第一维通常是枚举区间长度</strong>，并且一般<code> len = 1</code> 时用来初始化，枚举<strong>从 len &#x3D; 2 开始</strong>；第二维枚举起点 i （右端点 j <strong>自动获得</strong>，<code>j = i + len - 1</code>）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目整理"><a href="#题目整理" class="headerlink" title="题目整理"></a>题目整理</h3><blockquote>
<p>1.<a href="https://www.acwing.com/problem/content/284/">石子合并</a><br>2.<a href="https://leetcode.cn/problems/scramble-string/submissions/577101308/">leetcode87 扰乱字符串</a></p>
</blockquote>
<hr>
<h4 id="1-石子合并"><a href="#1-石子合并" class="headerlink" title="1.石子合并"></a>1.石子合并</h4><blockquote>
<p>采用闫式dp分析法,本题的关键点在于：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并。<br><img src="/images/acwing/dp/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6.jpg"><br><code>f[i][j</code>表示将<code>i</code>到<code>j</code>这一段石子合并成一堆的方案的集合，属性为Min.依据上图的状态计算可以得到最终的答案就是f[1][n].</p>
</blockquote>
<ul>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">310</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// f[i][j]表示合并区间[i,j]这些石子的方案 属性为Min</span></span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) s[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区间dp枚举的是dp的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左端点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i, r = i + len - <span class="number">1</span>;</span><br><span class="line">                f[l][r] = Integer.MAX_VALUE; <span class="comment">// 因为要求最小值 初始化f[i][j]为最大值</span></span><br><span class="line">                <span class="comment">// 枚举[i,j]区间里最小代价的方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt; r; k++) &#123;</span><br><span class="line">                    f[l][r] = Math.min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(f[<span class="number">1</span>][n]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a>扰乱字符串</h4><p><img src="/images/acwing/dp/87.png" alt="题目描述"></p>
<ul>
<li><p>题目分析:</p>
<blockquote>
<p>本题中对于字符串的两种操作，首先是两个字符串<code>s1</code>和<code>s2</code>，也就是说如果采用<code>dp</code>的思路，状态表示的时候需要二维<code>f[i][j]</code>,并且<code>i</code>和<code>j</code>分别表示<code>s1</code>和<code>s2</code>的起点。此外，对于区间dp来说，首先枚举的一定是区间的长度,因此状态表示<code>f[i][j][k]</code>。</p>
</blockquote>
</li>
<li><p><code>f[i][j][k]</code></p>
<blockquote>
<p>集合：<code>s1[i ~ i + k - 1]</code>与<code>s2[j, j + k - 1]</code>所有匹配方案的集合<br>属性： 集合是否非空</p>
</blockquote>
</li>
<li><p>状态计算<br><img src="/images/acwing/dp/leetcode87.png" alt="解题思路"></p>
<blockquote>
<p>将<code>f[i, j, k]</code>表示的集合按<code>s1</code>第一段的长度划分划分成<code>k - 1</code>类。<br>设<code>s1</code>第一段的长度为<code>u</code>。则<code>s1[i ~ i + k - 1]</code>与<code>s2[j, j + k - 1]</code>有两种匹配方案，分别判断即可：<br>(1).<code>f[i][j][u] &amp;&amp; f[i + u][j + u][k - u]</code>.<br>(2).<code>f[i][j][u] &amp;&amp; f[i + u][j + u][k - u]</code></p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i][j][k]表示s1[i,i+k-1]和s2[j,j+k-1]所有的匹配方案 属性是是否非空</span></span><br><span class="line">        <span class="type">boolean</span>[][][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区间dp枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j + k - <span class="number">1</span> &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j)) f[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">1</span>; u &lt; k; u++) &#123;</span><br><span class="line">                            <span class="comment">// 状态计算</span></span><br><span class="line">                            <span class="keyword">if</span>(f[i][j][u] &amp;&amp; f[i + u][j + u][k - u] || f[i][j + k - u][u] &amp;&amp; f[i + u][j][k - u]) &#123;</span><br><span class="line">                                f[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>未完待续</p>
]]></content>
      <categories>
        <category>java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>一文解决算法中的解码问题</title>
    <url>/2024/11/02/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="解码问题-线性dp"><a href="#解码问题-线性dp" class="headerlink" title="解码问题-线性dp"></a>解码问题-线性dp</h2><h3 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h3><blockquote>
<ol>
<li><a href="https://leetcode.cn/problems/decode-ways/description/">解码方法I</a></li>
<li><a href="https://leetcode.cn/problems/decode-ways-ii/description/">解码方法II</a></li>
</ol>
</blockquote>
<hr>
<h4 id="解码方法I"><a href="#解码方法I" class="headerlink" title="解码方法I"></a>解码方法I</h4><p><img src="/images/acwing/dp/91.jpg"></p>
<ul>
<li><p>分析思路：</p>
<blockquote>
<p>动态规划，这道题跟跳台阶非常相似。由题意可知，数字<code>[1-26]</code>对应<code>[a-z]</code>。分析时可以考虑对于数字<code>[1-9]</code>，只能是一个数字对应一个字母<code>[a-j]</code>;但是对于数字<code>[11-26]</code>,可能对应两个字母，也可能对应一个字母。例如：12可以对应<code>[ab]</code>和<code>l</code>。因此要分别考虑这两种情况。对于具体做法，考虑使用<strong>动态规划</strong>。<br>  <img src="/images/acwing/dp/leetcode91.jpg" alt="在这里插入图片描述"></p>
</blockquote>
</li>
<li><p>状态表示</p>
<blockquote>
<p><code>f[i]</code>表示表示前 <code>i</code>个数字共有多少种解码方式<br>属性为方案数</p>
</blockquote>
</li>
<li><p>状态计算</p>
<blockquote>
<p>划分以最后一个解码的字母需要一个还是两个数字来分类。如果需要一个数字，那么满足第<code>i</code>个数字<code>[1-9]</code>即可，此时<code>f[i]</code>就由<code>f[i - 1]</code>转移得到；如果需要两个数字，需要满足这两个数字组成的新数字位于<code>[10-26]</code>，此时<code>f[i]</code>就由<code>f[i - 2]</code>转移得到。具体细节见代码:</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        <span class="comment">// f[i]表示s中的前i个字符可以正确解码的方案数</span></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// 最后一位数字代表一个字母</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 最后两个数字对应一个字母</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">26</span>) f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="解码方法II"><a href="#解码方法II" class="headerlink" title="解码方法II"></a>解码方法II</h4><p><img src="/images/acwing/dp/639.jpg"></p>
<ul>
<li><p>分析思路</p>
<blockquote>
<p>本题属于上题的进阶，添加了<code>*</code>这个限制，对于状态转移方程有了很多细节的考验。如果还是按照上题思路，会多很多的细节判断，尤其是在双字符解码时。<br><img src="/images/acwing/dp/639_1.jpg" alt="在这里插入图片描述"><br>为了减少这些繁琐的逻辑，可以思考：对于最后一个解码后的字母，无非就是<code>[a-z]</code>之间26种情况,因此我们可以多一重循环，枚举最后一个解码的字母，而对于这个字母，也可以分单数字解码和双数字解码进行状态转移，这样最后的逻辑要更加简单一些。<br>注意：因为添加了<code>*</code>的限制，而<code>*</code>可以代表<code>[1-9]</code>中的数，所以要添加当前数字位等于<code>*</code>这种情况的判断,具体细节见代码。</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span>[] f = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// j枚举的是可解码的最后一个字母对应的数字(1-26) 对应a-Z</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> s.charAt(i); <span class="comment">//a表示当前位数字</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单字符解码</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="string">&#x27;*&#x27;</span> || a == (<span class="type">char</span>)(j + <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">                        f[i] = (f[i] + f[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 双字符解码</span></span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> s.charAt(i - <span class="number">1</span>); <span class="comment">// 取当前位的前一位数字</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j / <span class="number">10</span>, x = j % <span class="number">10</span>;<span class="comment">// 求出来如果是双字符解码，要解码的数字是多少 y是十位 x是个位</span></span><br><span class="line">                    <span class="keyword">if</span> ((b == (<span class="type">char</span>)(y + <span class="string">&#x27;0&#x27;</span>) || (b == <span class="string">&#x27;*&#x27;</span> &amp;&amp; y != <span class="number">0</span>)) &amp;&amp; (a == (<span class="type">char</span>)(x + <span class="string">&#x27;0&#x27;</span>) || (a == <span class="string">&#x27;*&#x27;</span> &amp;&amp; x != <span class="number">0</span>))) &#123;</span><br><span class="line">                        f[i] = (f[i] + f[i - <span class="number">2</span>]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>另外，在代码中为了防止处理边界，我都是将s前面添加一个空格，这样可以使得枚举的<code>i</code>是<code>[1 - n]</code>的，减少边界条件的处理，还要注意本题中的MOD运算。</p>
</blockquote>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
</search>
