<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My new Post</title>
    <url>/2024/10/27/My-new-Post/</url>
    <content><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><pre><code>这是我的第一篇博客
</code></pre>
<h4 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h4><pre><code>激动的心情
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>单调栈的应用1</title>
    <url>/2024/10/28/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A81/</url>
    <content><![CDATA[<h3 id="单调栈的定义："><a href="#单调栈的定义：" class="headerlink" title="单调栈的定义："></a>单调栈的定义：</h3><blockquote>
<p>单调栈是栈的一中特殊形式，在栈中的元素必须满足单调性（一定是单调上升或单调下降等等的规律）。</p>
</blockquote>
<hr>
<h3 id="单调栈的性质："><a href="#单调栈的性质：" class="headerlink" title="单调栈的性质："></a>单调栈的性质：</h3><ul>
<li><h4 id="单调栈解决的问题"><a href="#单调栈解决的问题" class="headerlink" title="单调栈解决的问题"></a>单调栈解决的问题</h4></li>
</ul>
<blockquote>
<p>单调栈解决的常见问题：给定一个序列，求每个位置左边，离他最近且小于他的数的位置。<br>我们可以这样理解单调栈：<br>既然我们必须让元素满足单调性，那么每次插入就和栈顶作比较。<br>如果不满足某些性质，直接弹出栈顶，直到栈为空或满足该性质插入这个元素。</p>
</blockquote>
<hr>
<ul>
<li><h4 id="如何维护一个单调栈"><a href="#如何维护一个单调栈" class="headerlink" title="如何维护一个单调栈"></a>如何维护一个单调栈</h4></li>
</ul>
<blockquote>
<p>单调递增栈：在保持栈内元素单调递增的前提下（如果栈顶元素大于要入栈的元素，将将其弹出），将新元素入栈。<br>单调递减栈：在保持栈内元素单调递减的前提下（如果栈顶元素小于要入栈的元素，则将其弹出），将新元素入栈。</p>
</blockquote>
<hr>
<ul>
<li><h4 id="单调栈的规律"><a href="#单调栈的规律" class="headerlink" title="单调栈的规律"></a>单调栈的规律</h4></li>
</ul>
<p><img src="/images/%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg"><br><img src="/images/%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg"></p>
<hr>
<h3 id="单调栈练习题汇总"><a href="#单调栈练习题汇总" class="headerlink" title="单调栈练习题汇总"></a>单调栈练习题汇总</h3><ul>
<li><strong>已解决</strong><blockquote>
<p>1 <a href="https://www.acwing.com/problem/content/832/">模拟单调栈</a><br>2 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">leetocde T84柱形图中的最大矩形</a></p>
</blockquote>
</li>
<li>未完待续</li>
</ul>
<hr>
<h3 id="模拟单调栈"><a href="#模拟单调栈" class="headerlink" title="模拟单调栈"></a>模拟单调栈</h3><ul>
<li>分析<blockquote>
<p>本题是单调栈的模板题，可以用数组模拟单调栈，但是我个人更喜欢用Stack集合调用API的方式。</p>
</blockquote>
</li>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) q[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; q[stk.peek()] &gt;= q[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) System.out.print(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(q[stk.peek()] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="柱形图中的最大矩形"><a href="#柱形图中的最大矩形" class="headerlink" title="柱形图中的最大矩形"></a>柱形图中的最大矩形</h3><ul>
<li>题目分析：<blockquote>
<p>本题中在该柱状图中，求能够勾勒出来的矩形的最大面积这个问题，可以模拟样例，想一想如何解决这个面积问题？<br>首先对于面积，需要底×高，高度跟每个柱子的高度有关，底和对应柱子的下标有关系。正确的思路是枚举每个柱子的高度，以这个高度向左右两边进行扩展，如果能找到当前柱子左右两边的离他最近且小于他的高度的柱子,那么这个柱子所能构成的最大矩形面积就是用当前的柱子的高度<code>h[i] * (right[i] - left[i] - 1) </code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>为什么要减1？</strong><br><code>right[i] - left[i]</code>：这是从<code> left[i]</code> 到 <code>right[i]</code> 之间的距离，但这包括了<code>left[i]</code>和 <code>right[i]</code> 本身。<br>我们真正关心的是柱子<code> i</code> 左边和右边，第一个小于它的柱子之间的距离，所以不包括 <code>left[i]</code> 和<code> right[i]</code>，而是 <code>left[i]</code> 和<code> right[i]</code> 之间的元素个数。因此，要在 <code>right[i] - left[i]</code> 的基础上再减去 1。<br><strong>举例：</strong><br>假设 <code>heights = [2, 1, 5, 6, 2, 3]</code>，我们考察柱子<code>i = 2</code>(即高度为 5 的柱子):<br><code>left[2] = 1</code>：在 <code>heights[2]</code> 左边，第一个小于 5 的柱子在索引 1。<br><code>right[2] = 4</code>：在 <code>heights[2]</code> 右边，第一个小于 5 的柱子在索引 4。<br>所以 <code>right[2]</code> -<code> left[2]</code> - 1 &#x3D; 4 - 1 - 1 &#x3D; 2。<br>这表示柱子 i &#x3D; 2 的宽度为 2（包括自己）时，高度为 5 的矩形面积最大。因此，面积为<code> heights[2] * (right[2] - left[2] - 1) = 5 * 2 = 10</code>。</p>
</blockquote>
<ul>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[stk.peek()] &gt;= heights[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) left[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护当前元素的右边比自己小的最近的数的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[stk.peek()] &gt;= heights[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) right[i] = n;</span><br><span class="line">            <span class="keyword">else</span> right[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
</search>
