<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单调栈的应用1</title>
    <url>/2024/10/28/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A81/</url>
    <content><![CDATA[<h3 id="单调栈的定义："><a href="#单调栈的定义：" class="headerlink" title="单调栈的定义："></a>单调栈的定义：</h3><blockquote>
<p>单调栈是栈的一中特殊形式，在栈中的元素必须满足单调性（一定是单调上升或单调下降等等的规律）。</p>
</blockquote>
<hr>
<h3 id="单调栈的性质："><a href="#单调栈的性质：" class="headerlink" title="单调栈的性质："></a>单调栈的性质：</h3><ul>
<li><h4 id="单调栈解决的问题"><a href="#单调栈解决的问题" class="headerlink" title="单调栈解决的问题"></a>单调栈解决的问题</h4></li>
</ul>
<blockquote>
<p>单调栈解决的常见问题：给定一个序列，求每个位置左边，离他最近且小于他的数的位置。<br>我们可以这样理解单调栈：<br>既然我们必须让元素满足单调性，那么每次插入就和栈顶作比较。<br>如果不满足某些性质，直接弹出栈顶，直到栈为空或满足该性质插入这个元素。</p>
</blockquote>
<hr>
<ul>
<li><h4 id="如何维护一个单调栈"><a href="#如何维护一个单调栈" class="headerlink" title="如何维护一个单调栈"></a>如何维护一个单调栈</h4></li>
</ul>
<blockquote>
<p>单调递增栈：在保持栈内元素单调递增的前提下（如果栈顶元素大于要入栈的元素，将将其弹出），将新元素入栈。<br>单调递减栈：在保持栈内元素单调递减的前提下（如果栈顶元素小于要入栈的元素，则将其弹出），将新元素入栈。</p>
</blockquote>
<hr>
<ul>
<li><h4 id="单调栈的规律"><a href="#单调栈的规律" class="headerlink" title="单调栈的规律"></a>单调栈的规律</h4></li>
</ul>
<p><img src="/images/%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg"><br><img src="/images/%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg"></p>
<hr>
<h3 id="单调栈练习题汇总"><a href="#单调栈练习题汇总" class="headerlink" title="单调栈练习题汇总"></a>单调栈练习题汇总</h3><ul>
<li><strong>已解决</strong><blockquote>
<p>1 <a href="https://www.acwing.com/problem/content/832/">模拟单调栈</a><br>2 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">leetocde T84柱形图中的最大矩形</a><br>3 <a href="https://leetcode.cn/problems/maximal-rectangle/description/">leetcode T85 最大矩形面积</a></p>
</blockquote>
</li>
<li>未完待续</li>
</ul>
<hr>
<h3 id="模拟单调栈"><a href="#模拟单调栈" class="headerlink" title="模拟单调栈"></a>模拟单调栈</h3><ul>
<li>分析<blockquote>
<p>本题是单调栈的模板题，可以用数组模拟单调栈，但是我个人更喜欢用Stack集合调用API的方式。</p>
</blockquote>
</li>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) q[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; q[stk.peek()] &gt;= q[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) System.out.print(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(q[stk.peek()] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="柱形图中的最大矩形"><a href="#柱形图中的最大矩形" class="headerlink" title="柱形图中的最大矩形"></a>柱形图中的最大矩形</h3><ul>
<li>题目分析：<blockquote>
<p>本题中在该柱状图中，求能够勾勒出来的矩形的最大面积这个问题，可以模拟样例，想一想如何解决这个面积问题？<br>首先对于面积，需要底×高，高度跟每个柱子的高度有关，底和对应柱子的下标有关系。正确的思路是枚举每个柱子的高度，以这个高度向左右两边进行扩展，如果能找到当前柱子左右两边的离他最近且小于他的高度的柱子,那么这个柱子所能构成的最大矩形面积就是用当前的柱子的高度<code>h[i] * (right[i] - left[i] - 1) </code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>为什么要减1？</strong><br><code>right[i] - left[i]</code>：这是从<code> left[i]</code> 到 <code>right[i]</code> 之间的距离，但这包括了<code>left[i]</code>和 <code>right[i]</code> 本身。<br>我们真正关心的是柱子<code> i</code> 左边和右边，第一个小于它的柱子之间的距离，所以不包括 <code>left[i]</code> 和<code> right[i]</code>，而是 <code>left[i]</code> 和<code> right[i]</code> 之间的元素个数。因此，要在 <code>right[i] - left[i]</code> 的基础上再减去 1。<br><strong>举例：</strong><br>假设 <code>heights = [2, 1, 5, 6, 2, 3]</code>，我们考察柱子<code>i = 2</code>(即高度为 5 的柱子):<br><code>left[2] = 1</code>：在 <code>heights[2]</code> 左边，第一个小于 5 的柱子在索引 1。<br><code>right[2] = 4</code>：在 <code>heights[2]</code> 右边，第一个小于 5 的柱子在索引 4。<br>所以 <code>right[2]</code> -<code> left[2]</code> - 1 &#x3D; 4 - 1 - 1 &#x3D; 2。<br>这表示柱子 i &#x3D; 2 的宽度为 2（包括自己）时，高度为 5 的矩形面积最大。因此，面积为<code> heights[2] * (right[2] - left[2] - 1) = 5 * 2 = 10</code>。</p>
</blockquote>
<ul>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[stk.peek()] &gt;= heights[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) left[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护当前元素的右边比自己小的最近的数的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[stk.peek()] &gt;= heights[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) right[i] = n;</span><br><span class="line">            <span class="keyword">else</span> right[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="最大矩形的面积"><a href="#最大矩形的面积" class="headerlink" title="最大矩形的面积"></a>最大矩形的面积</h3><p><img src="/images/leetcode85.jpg" alt="最大的矩形面积示例"></p>
<ul>
<li><strong>分析</strong><blockquote>
<p>本题拿过来乍一看感觉非常困难，但是仔细想想，还是单调栈的应用。怎么把矩形面积和单调栈练习在一起呢？<br>通过上面柱形图中的最大矩形面积这题可以得知，我们现在可以用单调栈的方法解决一个维度的面积，本题中的矩阵面积，不也可以想象成是把某一行当作基底，往上看连续的1个数就代表了柱形的高度。因此本题可以转换为，按行枚举每一行的柱子，然后按照上题的思路求出每一行的最大面积，然后扩展到二维。因此本题与上题的差别就在于，怎么枚举每一行的柱子高度，这就需要预处理出来<code>h[i][j]</code>。对于<code>h[i][j]</code>的表示和计算，我认为类似一个<code>dp</code>问题.</p>
</blockquote>
</li>
</ul>
<p><strong>状态表示:</strong></p>
<blockquote>
<ul>
<li><code>h[i,j]</code>表示所有以<code>(i,j)</code>为终点，能往上延伸的最大高度。</li>
</ul>
</blockquote>
<p><strong>状态计算:</strong></p>
<blockquote>
<ul>
<li>若当前位置是0，则<code>h[i,j] = 0</code></li>
<li>若当前位置是1，则<code>h[i,j] = 1 + h[i,j]</code></li>
</ul>
</blockquote>
<ul>
<li>代码 时间复杂度 : O($n^2$)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] h = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 预处理出来矩形的高度 dp的思想</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>) h[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> h[i][j] = <span class="number">1</span> + h[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按行枚举基准线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) ans = Math.max(ans, getReactangeArea(h[i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getReactangeArea</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[ n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; h[stk.peek()] &gt;= h[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) left[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; h[stk.peek()] &gt;= h[i]) stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()) right[i] = n ;</span><br><span class="line">            <span class="keyword">else</span> right[i] = stk.peek();</span><br><span class="line"></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) res = Math.max(res, (right[i] - left[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底解决区间dp问题</title>
    <url>/2024/10/30/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4dp%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="区间dp的理解"><a href="#区间dp的理解" class="headerlink" title="区间dp的理解"></a>区间dp的理解</h3><blockquote>
<p>对于一段区间的元素进行操作，操作必须是连续的，求解，在这段区间上的属性(<strong>Min</strong> &#x2F; Max),考虑动态规划的考虑方式。</p>
</blockquote>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><blockquote>
<p>所有的区间dp问题枚举时，<strong>第一维通常是枚举区间长度</strong>，并且一般<code> len = 1</code> 时用来初始化，枚举<strong>从 len &#x3D; 2 开始</strong>；第二维枚举起点 i （右端点 j <strong>自动获得</strong>，<code>j = i + len - 1</code>）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目整理"><a href="#题目整理" class="headerlink" title="题目整理"></a>题目整理</h3><blockquote>
<p>1.<a href="https://www.acwing.com/problem/content/284/">石子合并</a><br>2.<a href="https://leetcode.cn/problems/scramble-string/submissions/577101308/">leetcode87 扰乱字符串</a></p>
</blockquote>
<hr>
<h4 id="1-石子合并"><a href="#1-石子合并" class="headerlink" title="1.石子合并"></a>1.石子合并</h4><blockquote>
<p>采用闫式dp分析法,本题的关键点在于：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并。<br><img src="/images/acwing/dp/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6.jpg"><br><code>f[i][j</code>表示将<code>i</code>到<code>j</code>这一段石子合并成一堆的方案的集合，属性为Min.依据上图的状态计算可以得到最终的答案就是f[1][n].</p>
</blockquote>
<ul>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">310</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// f[i][j]表示合并区间[i,j]这些石子的方案 属性为Min</span></span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) s[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区间dp枚举的是dp的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左端点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i, r = i + len - <span class="number">1</span>;</span><br><span class="line">                f[l][r] = Integer.MAX_VALUE; <span class="comment">// 因为要求最小值 初始化f[i][j]为最大值</span></span><br><span class="line">                <span class="comment">// 枚举[i,j]区间里最小代价的方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt; r; k++) &#123;</span><br><span class="line">                    f[l][r] = Math.min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(f[<span class="number">1</span>][n]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a>扰乱字符串</h4><p><img src="/images/acwing/dp/87.png" alt="题目描述"></p>
<ul>
<li><p>题目分析:</p>
<blockquote>
<p>本题中对于字符串的两种操作，首先是两个字符串<code>s1</code>和<code>s2</code>，也就是说如果采用<code>dp</code>的思路，状态表示的时候需要二维<code>f[i][j]</code>,并且<code>i</code>和<code>j</code>分别表示<code>s1</code>和<code>s2</code>的起点。此外，对于区间dp来说，首先枚举的一定是区间的长度,因此状态表示<code>f[i][j][k]</code>。</p>
</blockquote>
</li>
<li><p><code>f[i][j][k]</code></p>
<blockquote>
<p>集合：<code>s1[i ~ i + k - 1]</code>与<code>s2[j, j + k - 1]</code>所有匹配方案的集合<br>属性： 集合是否非空</p>
</blockquote>
</li>
<li><p>状态计算<br><img src="/images/acwing/dp/leetcode87.png" alt="解题思路"></p>
<blockquote>
<p>将<code>f[i, j, k]</code>表示的集合按<code>s1</code>第一段的长度划分划分成<code>k - 1</code>类。<br>设<code>s1</code>第一段的长度为<code>u</code>。则<code>s1[i ~ i + k - 1]</code>与<code>s2[j, j + k - 1]</code>有两种匹配方案，分别判断即可：<br>(1).<code>f[i][j][u] &amp;&amp; f[i + u][j + u][k - u]</code>.<br>(2).<code>f[i][j][u] &amp;&amp; f[i + u][j + u][k - u]</code></p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i][j][k]表示s1[i,i+k-1]和s2[j,j+k-1]所有的匹配方案 属性是是否非空</span></span><br><span class="line">        <span class="type">boolean</span>[][][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区间dp枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j + k - <span class="number">1</span> &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j)) f[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">1</span>; u &lt; k; u++) &#123;</span><br><span class="line">                            <span class="comment">// 状态计算</span></span><br><span class="line">                            <span class="keyword">if</span>(f[i][j][u] &amp;&amp; f[i + u][j + u][k - u] || f[i][j + k - u][u] &amp;&amp; f[i + u][j][k - u]) &#123;</span><br><span class="line">                                f[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>未完待续</p>
]]></content>
      <categories>
        <category>java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>一文解决算法中的解码问题</title>
    <url>/2024/11/02/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="解码问题-线性dp"><a href="#解码问题-线性dp" class="headerlink" title="解码问题-线性dp"></a>解码问题-线性dp</h2><h3 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h3><blockquote>
<ol>
<li><a href="https://leetcode.cn/problems/decode-ways/description/">解码方法I</a></li>
<li><a href="https://leetcode.cn/problems/decode-ways-ii/description/">解码方法II</a></li>
</ol>
</blockquote>
<hr>
<h4 id="解码方法I"><a href="#解码方法I" class="headerlink" title="解码方法I"></a>解码方法I</h4><p><img src="/images/acwing/dp/91.jpg"></p>
<ul>
<li><p>分析思路：</p>
<blockquote>
<p>动态规划，这道题跟跳台阶非常相似。由题意可知，数字<code>[1-26]</code>对应<code>[a-z]</code>。分析时可以考虑对于数字<code>[1-9]</code>，只能是一个数字对应一个字母<code>[a-j]</code>;但是对于数字<code>[11-26]</code>,可能对应两个字母，也可能对应一个字母。例如：12可以对应<code>[ab]</code>和<code>l</code>。因此要分别考虑这两种情况。对于具体做法，考虑使用<strong>动态规划</strong>。<br>  <img src="/images/acwing/dp/leetcode91.jpg" alt="在这里插入图片描述"></p>
</blockquote>
</li>
<li><p>状态表示</p>
<blockquote>
<p><code>f[i]</code>表示表示前 <code>i</code>个数字共有多少种解码方式<br>属性为方案数</p>
</blockquote>
</li>
<li><p>状态计算</p>
<blockquote>
<p>划分以最后一个解码的字母需要一个还是两个数字来分类。如果需要一个数字，那么满足第<code>i</code>个数字<code>[1-9]</code>即可，此时<code>f[i]</code>就由<code>f[i - 1]</code>转移得到；如果需要两个数字，需要满足这两个数字组成的新数字位于<code>[10-26]</code>，此时<code>f[i]</code>就由<code>f[i - 2]</code>转移得到。具体细节见代码:</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        <span class="comment">// f[i]表示s中的前i个字符可以正确解码的方案数</span></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// 最后一位数字代表一个字母</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 最后两个数字对应一个字母</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">26</span>) f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="解码方法II"><a href="#解码方法II" class="headerlink" title="解码方法II"></a>解码方法II</h4><p><img src="/images/acwing/dp/639.jpg"></p>
<ul>
<li><p>分析思路</p>
<blockquote>
<p>本题属于上题的进阶，添加了<code>*</code>这个限制，对于状态转移方程有了很多细节的考验。如果还是按照上题思路，会多很多的细节判断，尤其是在双字符解码时。<br><img src="/images/acwing/dp/639_1.jpg" alt="在这里插入图片描述"><br>为了减少这些繁琐的逻辑，可以思考：对于最后一个解码后的字母，无非就是<code>[a-z]</code>之间26种情况,因此我们可以多一重循环，枚举最后一个解码的字母，而对于这个字母，也可以分单数字解码和双数字解码进行状态转移，这样最后的逻辑要更加简单一些。<br>注意：因为添加了<code>*</code>的限制，而<code>*</code>可以代表<code>[1-9]</code>中的数，所以要添加当前数字位等于<code>*</code>这种情况的判断,具体细节见代码。</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span>[] f = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// j枚举的是可解码的最后一个字母对应的数字(1-26) 对应a-Z</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> s.charAt(i); <span class="comment">//a表示当前位数字</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单字符解码</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="string">&#x27;*&#x27;</span> || a == (<span class="type">char</span>)(j + <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">                        f[i] = (f[i] + f[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 双字符解码</span></span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> s.charAt(i - <span class="number">1</span>); <span class="comment">// 取当前位的前一位数字</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j / <span class="number">10</span>, x = j % <span class="number">10</span>;<span class="comment">// 求出来如果是双字符解码，要解码的数字是多少 y是十位 x是个位</span></span><br><span class="line">                    <span class="keyword">if</span> ((b == (<span class="type">char</span>)(y + <span class="string">&#x27;0&#x27;</span>) || (b == <span class="string">&#x27;*&#x27;</span> &amp;&amp; y != <span class="number">0</span>)) &amp;&amp; (a == (<span class="type">char</span>)(x + <span class="string">&#x27;0&#x27;</span>) || (a == <span class="string">&#x27;*&#x27;</span> &amp;&amp; x != <span class="number">0</span>))) &#123;</span><br><span class="line">                        f[i] = (f[i] + f[i - <span class="number">2</span>]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>另外，在代码中为了防止处理边界，我都是将s前面添加一个空格，这样可以使得枚举的<code>i</code>是<code>[1 - n]</code>的，减少边界条件的处理，还要注意本题中的MOD运算。</p>
</blockquote>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习1</title>
    <url>/2024/11/04/React%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><blockquote>
<p>1.安装终端 推荐使用git bash</p>
<p>2.安装<code>nodejs</code></p>
<p>3.安装react 这里建议使用<code>npx create-react-app my-app</code></p>
<p>4.安装<code>vscode</code>插件 <code>Simple React Snippets</code>   <code>Prettier - Code formatter</code></p>
<p>5.创建项目</p>
<ul>
<li><code>cd my-app</code></li>
<li><code>npm start</code></li>
</ul>
</blockquote>
<blockquote>
<p>在React项目结构中，<code>index.html</code>中只有一个root，在<code>js</code>中渲染出来，实际的页面内容在<code>src/App.js</code>中，可以看到这里面可以写<code>html</code>代码，实际上这是<code>JSX</code>,但是<code>jsx</code>后续会使用<code>babel</code>编译成<code>js</code></p>
</blockquote>
<h3 id="ES6语法补充"><a href="#ES6语法补充" class="headerlink" title="ES6语法补充"></a>ES6语法补充</h3><ul>
<li>使用bind()函数绑定this的取值</li>
</ul>
<blockquote>
<p>在JavaScript中，函数里的this指向的是执行时的调用者，而非定义时所在的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yxc&quot;</span>,</span><br><span class="line">  <span class="attr">talk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">talk</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> talk = person.<span class="property">talk</span>;</span><br><span class="line"><span class="title function_">talk</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>: <span class="string">&#x27;yxc&#x27;</span>, <span class="attr">talk</span>: ƒ&#125;</span><br><span class="line"><span class="title class_">Window</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> bind()函数，可以绑定this的取值。例如</p>
<p><code>const talk = person.talk.bind(person);</code></p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>: <span class="string">&#x27;yxc&#x27;</span>, <span class="attr">talk</span>: ƒ&#125;</span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">&#x27;yxc&#x27;</span>, <span class="attr">talk</span>: ƒ&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>箭头函数的简写方式</p>
<blockquote>
<p>当只有一个参数可以去掉参数的括号；当函数体只有一句话，可以去掉大括号和return</p>
</blockquote>
<blockquote>
<p> <code>const f = (x) =&gt; &#123;   return x * x; &#125;;</code></p>
<p>可以简写为：</p>
<p><code> const f = x =&gt; x * x;</code></p>
</blockquote>
</li>
<li><p>箭头函数不重新绑定this的取值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">talk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">talk</span>();  <span class="comment">// 输出Window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">talk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">talk</span>();  <span class="comment">// 输出 &#123;talk: f&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的解构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yxc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name : nm, age&#125; = person;  <span class="comment">// nm是name的别名</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>数组和对象的展开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [...a];  <span class="comment">// b是a的复制</span></span><br><span class="line"><span class="keyword">let</span> c = [...a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">name</span>: <span class="string">&quot;yxc&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b, <span class="attr">height</span>: <span class="number">180</span>&#125;;</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>Named 与 Default exports</p>
<blockquote>
<p>通俗理解: 想import一个默认值的话，就不能加{}，同时名字可以随便起;想import一个非默认值的话，必须加{},名字必须对应。</p>
</blockquote>
<blockquote>
<p>Named Export：可以export多个，import的时候需要加大括号，名称需要匹配</p>
<p>Default Export：最多export一个，import的时候不需要加大括号，可以直接定义别名</p>
</blockquote>
<hr>
</li>
</ul>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul>
<li><p>1,创建项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create-react-app box-app</span><br><span class="line">cd box-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装bootstrap库</p>
<p><code>npm i bootstrap</code></p>
<p>引入boostrap: 在<code>index.js</code>中：<code>import &#39;bootstrap/dist/css/bootstrap.css&#39;;</code></p>
<p>自己在src&#x2F;components中新建一个<code>box.jsx</code></p>
<ul>
<li>1.键入imrc + TAB 补全</li>
<li>2.键入 cc + TAB补全</li>
</ul>
</blockquote>
</li>
<li><p>2.创建Component</p>
<blockquote>
<p>创建按钮</p>
<p>当子节点的个数大于1的时候，可以用<code>&lt;div&gt;</code>或者<code>&lt;React.Fragment&gt;</code>将其括起来</p>
<p>内嵌表达式:</p>
<p>JSX中使用{}嵌入表达式。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.tostring()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>left<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">tostring</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;x&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`x : <span class="subst">$&#123;x&#125;</span>`</span> <span class="comment">//  解构函数的写法</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Box</span>;</span><br></pre></td></tr></table></figure>

<p><code>state</code>里面存储的相当于局部变量。</p>
<p>设置属性：</p>
<ul>
<li>class -&gt; className</li>
<li>CSS属性：background-color -&gt; backgroundColor，其它属性类似</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">width:</span> &quot;<span class="attr">50px</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">height:</span> &quot;<span class="attr">50px</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">backgroundColor:</span> &quot;<span class="attr">lightblue</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">color:</span> &quot;<span class="attr">white</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">lineHeight:</span> &quot;<span class="attr">50px</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderRadius:</span> &quot;<span class="attr">50</span>%&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">cursor:</span> &quot;<span class="attr">pointer</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       &#125;&#125;&gt;</span>&#123;this.tostring()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>数据驱动改变Style 举例:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;&#123;/* // 外层的括号是表达式 里面的括号是对象 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;this.getStyles()&#125;</span>&gt;</span>&#123;this.tostring()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-primary m-2&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-success m-2 &quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getStyles</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> styles =  &#123;</span><br><span class="line">          <span class="attr">width</span>: <span class="string">&quot;50px&quot;</span>,</span><br><span class="line">          <span class="attr">height</span>: <span class="string">&quot;50px&quot;</span>,</span><br><span class="line">          <span class="attr">backgroundColor</span>: <span class="string">&quot;lightblue&quot;</span>,</span><br><span class="line">          <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">          <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">          <span class="attr">lineHeight</span>: <span class="string">&quot;50px&quot;</span>,</span><br><span class="line">          <span class="attr">borderRadius</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line">          <span class="attr">cursor</span>: <span class="string">&quot;pointer&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          styles.<span class="property">backgroundColor</span> = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> styles;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="title function_">tostring</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;x&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`x : <span class="subst">$&#123;x&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Box</span>;</span><br></pre></td></tr></table></figure>

<p>利用逻辑表达式的短路原则。</p>
<ul>
<li>与表达式中 expr1 &amp;&amp; expr2，当expr1为假时返回expr1的值，否则返回expr2的值</li>
<li>或表达式中 expr1 || expr2，当expr1为真时返回expr1的值，否则返回expr2的值</li>
</ul>
<p>绑定事件</p>
<ul>
<li>注意妥善处理好绑定事件函数的this</li>
</ul>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 这里传入的是函数 而不是函数的返回值 所以不是this.handleClickLeft()  */</span>&#125;</span><br><span class="line">        &lt;button type=<span class="string">&quot;button&quot;</span> onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClickLeft</span>&#125; className=<span class="string">&quot;btn btn-primary m-2&quot;</span>&gt;left&lt;/button&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClickRight&#125;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-success m-2 &quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>修改state</p>
<ul>
<li>需要使用this.setState()函数</li>
<li>每次调用this.setState()函数后，会重新调用this.render()函数，用来修改虚拟DOM树。React只会修改不同步的实际DOM树节点。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">color</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>],</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">//  箭头函数不会改变this的指向</span></span><br><span class="line">   handleClickLeft = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用setState方法改变状态 不仅可以改变状态 还可以触发组件的重新渲染</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> - <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   handleClickRight = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> + <span class="number">1</span></span><br><span class="line">       &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;&#123;/* // 外层的括号是表达式 里面的括号是对象 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;this.getStyles()&#125;</span>&gt;</span>&#123;this.tostring()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 这里传入的是函数 而不是函数的返回值 所以不是this.handleClickLeft()  */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClickLeft&#125;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-primary m-2&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClickRight&#125;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-success m-2 &quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;this.state.color.length === 0 &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>no color<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;this.state.color.map(color =&gt;(</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;color&#125;</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getStyles</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> styles =  &#123;</span><br><span class="line">          <span class="attr">width</span>: <span class="number">50</span>,</span><br><span class="line">          <span class="attr">height</span>: <span class="number">50</span>,</span><br><span class="line">          <span class="attr">backgroundColor</span>: <span class="string">&quot;lightblue&quot;</span>,</span><br><span class="line">          <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">          <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">          <span class="attr">lineHeight</span>: <span class="string">&quot;50px&quot;</span>,</span><br><span class="line">          <span class="attr">borderRadius</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line">          <span class="attr">cursor</span>: <span class="string">&quot;pointer&quot;</span>,</span><br><span class="line">          <span class="attr">marginLeft</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> * <span class="number">10</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          styles.<span class="property">backgroundColor</span> = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> styles;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="title function_">tostring</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;x&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`x : <span class="subst">$&#123;x&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Box</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>只要一修改绑定事件的函数，通过state状态改变的setState()函数，会立即重新调用this.render()。</p>
</blockquote>
<p>给事件函数添加参数</p>
<p>1.写出来临时函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleClickLeft = <span class="function">(<span class="params">step</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 使用setState方法改变状态 不仅可以改变状态 还可以触发组件的重新渲染</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">           <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> - step</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  定义临时函数</span></span><br><span class="line">   handlClickLeftTmp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleClickLeft</span>(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &gt;<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> &gt;&#123;/* // 外层的括号是表达式 里面的括号是对象 */&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;this.getStyles()&#125;</span>&gt;</span>&#123;this.tostring()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;/* 这里传入的是函数 而不是函数的返回值 所以不是this.handleClickLeft()  */&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handlClickLeftTmp&#125;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-primary m-2&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClickRight&#125;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-success m-2 &quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;this.state.color.length === 0 &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>no color<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">       &#123;this.state.color.map(color =&gt;(</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;color&#125;</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           ))&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>2.采用匿名函数的形式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleClickLeft = <span class="function">(<span class="params">step</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 使用setState方法改变状态 不仅可以改变状态 还可以触发组件的重新渲染</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">           <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> - step</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClickRight = <span class="function">(<span class="params">step</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">           <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span> + step</span><br><span class="line">        &#125;)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &gt;<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> this.handleClickLeft(10)&#125; className=&quot;btn btn-primary m-2&quot;&gt;left<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> this.handleClickRight(10)&#125; className=&quot;btn btn-success m-2 &quot;&gt;right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="表格案例"><a href="#表格案例" class="headerlink" title="表格案例"></a>表格案例</h3><blockquote>
<p>使用bootstrap + React，实现一个可变表格的小demo</p>
</blockquote>
<p><code>index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Solution</span> <span class="keyword">from</span> <span class="string">&quot;./components/solution&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;bootstrap/dist/css/bootstrap.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Solution</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>solution.jsx</code>:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="comment">// 存储内容</span></span><br><span class="line">        <span class="attr">solutions</span>: [</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">10</span>,<span class="attr">number</span>: <span class="number">1164</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件1&quot;</span>,<span class="attr">view</span>: <span class="number">2930</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">11</span>,<span class="attr">number</span>: <span class="number">1165</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件2&quot;</span>,<span class="attr">view</span>: <span class="number">2931</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">12</span>,<span class="attr">number</span>: <span class="number">1166</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件3&quot;</span>,<span class="attr">view</span>: <span class="number">2932</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">13</span>,<span class="attr">number</span>: <span class="number">1167</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件4&quot;</span>,<span class="attr">view</span>: <span class="number">2933</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">14</span>,<span class="attr">number</span>: <span class="number">1168</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件5&quot;</span>,<span class="attr">view</span>: <span class="number">2934</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">15</span>,<span class="attr">number</span>: <span class="number">1169</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件6&quot;</span>,<span class="attr">view</span>: <span class="number">2935</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">16</span>,<span class="attr">number</span>: <span class="number">1170</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件7&quot;</span>,<span class="attr">view</span>: <span class="number">2936</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">key</span>: <span class="number">17</span>,<span class="attr">number</span>: <span class="number">1171</span>,<span class="attr">title</span>: <span class="string">&quot;加工零件8&quot;</span>,<span class="attr">view</span>: <span class="number">2937</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 添加 按钮点击事件</span></span><br><span class="line">    handleAdd = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> solutions = [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">solutions</span>, &#123;</span><br><span class="line">            <span class="attr">key</span>: s.<span class="property">key</span> + <span class="number">100</span>,</span><br><span class="line">            <span class="attr">number</span>: s.<span class="property">number</span> + <span class="number">1</span>,</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;加工零件&quot;</span> + (s.<span class="property">key</span> + <span class="number">100</span>),</span><br><span class="line">            <span class="attr">view</span>: s.<span class="property">view</span> + <span class="number">1</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">solutions</span>: solutions</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除按钮点击事件</span></span><br><span class="line">    handleDelete = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历solutions里的所有元素 如果不一样就保留 反之删除</span></span><br><span class="line">        <span class="keyword">const</span> solutions = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">solutions</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">solution</span> =&gt;</span> solution !== s);</span><br><span class="line">        <span class="comment">// 更新state里的solutions 更新后重新渲染页面</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">solutions</span>: solutions</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">solutions</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>暂无数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">className</span>=<span class="string">&quot;table&quot;</span> <span class="attr">style</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">textAlign:</span> &quot;<span class="attr">center</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">width:</span> &quot;<span class="attr">100</span>%&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">marginTop:</span> &quot;<span class="attr">20px</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">borderCollapse:</span> &quot;<span class="attr">collapse</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">th</span>&gt;</span>#<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">th</span>&gt;</span>阅读<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;this.state.solutions.map(solution =&gt; (</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;solution.key&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;solution.number&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;solution.title&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;solution.view&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            &#123;/* 给删除按钮绑定点击事件 */&#125;</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleDelete(solution)&#125;&gt;删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Solution</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="组合Components"><a href="#组合Components" class="headerlink" title="组合Components"></a>组合Components</h3><ul>
<li><ol>
<li><p>创建<code>Boxes</code>组件 <code>Boxes</code>组件中包含一系列<code>Box</code>组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Box</span> <span class="keyword">from</span> <span class="string">&#x27;./box&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boxes</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    state = &#123; </span><br><span class="line">        <span class="attr">boxes</span>: [</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">x</span>: <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">x</span>: <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">x</span>: <span class="number">0</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                // React 要求在列表中每个子元素都需要有唯一的 key 属性</span></span><br><span class="line"><span class="language-xml">            this.state.boxes.map(box =&gt; (              </span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Box</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">x</span> = <span class="string">&#123;box.x&#125;</span> // <span class="attr">自上向下传递参数</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">name</span> = <span class="string">&#123;</span>&quot;<span class="attr">yxc</span>&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 <span class="attr">key</span>=<span class="string">&#123;box.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Boxes</span>;</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>从上往下传递数据</p>
<p>boxes:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                // React 要求在列表中每个子元素都需要有唯一的 key 属性</span></span><br><span class="line"><span class="language-xml">            this.state.boxes.map(box =&gt; (              </span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Box</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">x</span> = <span class="string">&#123;box.x&#125;</span> // <span class="attr">自上向下传递参数</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">name</span> = <span class="string">&#123;</span>&quot;<span class="attr">yxc</span>&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">name</span>  // <span class="attr">只定义名字不定义值</span> <span class="attr">默认是true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 <span class="attr">key</span>=<span class="string">&#123;box.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>box:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">state = &#123; </span><br><span class="line">        <span class="attr">x</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">x</span>,</span><br><span class="line">     &#125;;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* // 外层的括号是表达式 里面的括号是对象 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;this.getStyles()&#125;</span>&gt;</span>&#123;this.tostring()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 这里传入的是函数 而不是函数的返回值 所以不是this.handleClickLeft()  */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> this.handleClickLeft(10)&#125; className=&quot;btn btn-primary m-2&quot;&gt;left<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> this.handleClickRight(10)&#125; className=&quot;btn btn-success m-2 &quot;&gt;right<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.color.length === 0 &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>no color<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;this.state.color.map(color =&gt;(</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;color&#125;</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在子节点box中添加删除按钮，画面渲染在父节点boxes上，可以使用prop的方法，自上而下传递。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">boxes</span>:</span><br><span class="line">handleDelete = <span class="function">(<span class="params">boxId</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 filter 方法遍历当前的 boxes 数组，并创建一个新数组</span></span><br><span class="line">        <span class="comment">// 过滤条件为：保留所有 id 不等于 boxId 的 box 对象</span></span><br><span class="line">        <span class="keyword">const</span> boxes = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">boxes</span>.<span class="title function_">filter</span>(</span><br><span class="line">            <span class="function"><span class="params">b</span> =&gt;</span> b.<span class="property">id</span> !== boxId <span class="comment">// 如果 box 的 id 不等于要删除的 boxId，则保留该 box</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 setState 更新组件的状态，将 boxes 设置为过滤后的新数组</span></span><br><span class="line">        <span class="comment">// React 会根据新的状态重新渲染组件，显示更新后的 boxes 列表</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; boxes&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                // React 要求在列表中每个子元素都需要有唯一的 key 属性</span></span><br><span class="line"><span class="language-xml">            this.state.boxes.map(box =&gt; (              </span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Box</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">x</span>=<span class="string">&#123;box.x&#125;</span> // <span class="attr">自上向下传递参数</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">id</span>=<span class="string">&#123;box.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">onDelete</span> =<span class="string">&#123;this.handleDelete&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 <span class="attr">key</span>=<span class="string">&#123;box.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">box</span>:</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> this.props.onDelete(this.props.id)&#125; </span></span><br><span class="line"><span class="language-xml">        className=&quot;btn btn-danger m-2&quot;&gt;</span></span><br><span class="line"><span class="language-xml">        Delete<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>传递子节点 通过<code>this.props.children</code>属性传递子节点</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">boxes</span>.<span class="title function_">map</span>(<span class="function"><span class="params">box</span> =&gt;</span> (              </span><br><span class="line">                 <span class="language-xml"><span class="tag">&lt;<span class="name">Box</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">x</span> = <span class="string">&#123;box.x&#125;</span> // <span class="attr">自上向下传递参数</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">name</span> = <span class="string">&#123;</span>&quot;<span class="attr">yxc</span>&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 <span class="attr">key</span>=<span class="string">&#123;box.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line">            ))</span><br></pre></td></tr></table></figure>


</li>
<li><p>从下往上调用函数</p>
<blockquote>
<p>注意：每个组件的this.state只能在组件内部修改，不能在其他组件内修改。</p>
</blockquote>
<ol start="4">
<li></li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream流的学习</title>
    <url>/2024/11/11/Stream%E6%B5%81%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Steam流，用于操作集合或者数组中的数据，大量结合了<code>Lamda</code>表达式的语法风格，代码简洁。</p>
<p>重点： 流只能收集一次</p>
</blockquote>
<p>​	<img src="/images/java/stream%E6%B5%81/1.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><blockquote>
<p>Stream流要与数据源建立连接。</p>
<p>1.list</p>
<p>​	直接调用<code>steam()</code>即可 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// list</span></span><br><span class="line">&gt;List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&gt;Collections.addAll(names, <span class="string">&quot;品贵&quot;</span>,<span class="string">&quot;红旗&quot;</span>, <span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">&gt;Stream&lt;String&gt; stream = names.stream();</span><br><span class="line">&gt;stream.filter(s -&gt; s.contains(<span class="string">&quot;品&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>2.set</p>
<p>​	直接调用<code>stream()</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//set</span></span><br><span class="line">&gt;Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&gt;Collections.addAll(set, <span class="string">&quot;品贵&quot;</span>,<span class="string">&quot;红旗&quot;</span>, <span class="string">&quot;三个人&quot;</span>, <span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">&gt;Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line">&gt;stream1.filter(s -&gt; s.contains(<span class="string">&quot;三&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>3.map</p>
<p>​	需要先将<code>map</code>转换为<code>entrySet()</code>,再通过<code>entryset()</code>进行获取<code>stream()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//map</span></span><br><span class="line">      Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">              put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">172.3</span>);</span><br><span class="line">              put(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">175.3</span>);</span><br><span class="line">              put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">171.4</span>);</span><br><span class="line">              put(<span class="string">&quot;稀里哗啦&quot;</span>, <span class="number">189.3</span>);</span><br><span class="line">              put(<span class="string">&quot;巴啦啦小魔仙&quot;</span>, <span class="number">160.1</span>);</span><br><span class="line">      &#125;&#125;;</span><br><span class="line">&gt;<span class="comment">//        map.stream()</span></span><br><span class="line">      Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">      Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();</span><br><span class="line">      kvs.filter(e -&gt; e.getKey().contains(<span class="string">&quot;巴&quot;</span>)).forEach(System.out::println);</span><br><span class="line">&gt;<span class="comment">// 简便写法</span></span><br><span class="line">&gt;map.entrySet().stream().filter(e -&gt; e.getKey().contains(<span class="string">&quot;巴&quot;</span>)).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>4.数组</p>
<p>​	使用<code>Arrays.stream()</code></p>
<p>​	使用<code>Stream.of()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//数组</span></span><br><span class="line">&gt;String[] names2 = &#123;<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;东方不败&quot;</span>, <span class="string">&quot;大唐不夜城&quot;</span>, <span class="string">&quot;回民街&quot;</span>&#125;;</span><br><span class="line">&gt;Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">&gt;Stream&lt;String&gt; s2 = Stream.of(names2);</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id><a href="#" class="headerlink" title></a><img src="/images/java/stream%E6%B5%81/2.png"></h2><h3 id="Steam流的常见中间方法"><a href="#Steam流的常见中间方法" class="headerlink" title="Steam流的常见中间方法"></a>Steam流的常见中间方法</h3><blockquote>
<p>中间方法指的是调用完成后会返回新的Stream流，可以继续使用，支持链式编程。</p>
</blockquote>
<p><img src="/images/java/stream%E6%B5%81/3.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找出大于60分并升序排序后输出</span></span><br><span class="line">        Collections.addAll(scores, <span class="number">88.5</span>, <span class="number">100.0</span>, <span class="number">60.6</span>, <span class="number">99.0</span>, <span class="number">9.5</span>, <span class="number">99.6</span>, <span class="number">25.9</span>);</span><br><span class="line">        scores.stream().filter(s -&gt; s &gt;= <span class="number">60</span>).sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">174.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">216</span>, <span class="number">122.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">175.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">13</span>, <span class="number">166.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5);</span><br><span class="line">        <span class="comment">// 找出年龄大于等于23 年龄小于等于30 并且按照年龄输出</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getAge() &gt;= <span class="number">23</span> &amp;&amp; s.getAge() &lt;= <span class="number">30</span>).sorted((o1, o2) -&gt; o2.getAge() - o1.getAge()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 取出身高前3名的学生 并输出</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight())).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 取出身高倒数2名学生，并输出</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).map(Student::getName).distinct().forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 找出身高超过168的学生叫什么名字，要求去除重复的内容，再输出</span></span><br><span class="line">        <span class="comment">// 首先需要重写equals和hashCode函数 让内容相同的对象设置为一样的</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).distinct().forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; st1 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; st2 = Stream.of(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;李四2&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        Stream.concat(st1, st2).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Stream流常见的终结方法"><a href="#Stream流常见的终结方法" class="headerlink" title="Stream流常见的终结方法"></a>Stream流常见的终结方法</h3><p><img src="/images/java/stream%E6%B5%81/4.png"><br><img src="/images/java/stream%E6%B5%81/5.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.8</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求1：计算身高超过168的人数</span></span><br><span class="line">        System.out.println(students.stream().filter(s -&gt; s.getHeight() &gt;= <span class="number">168</span>).count());</span><br><span class="line">        <span class="comment">//需求2：找出身高最高的学生对象并输出</span></span><br><span class="line">        System.out.println(students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get());</span><br><span class="line">        <span class="comment">//需求3：找出身高最矮的学生对象并输出</span></span><br><span class="line">        System.out.println(students.stream().min(((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight()))).get());</span><br><span class="line">        <span class="comment">//需求4：找出身高超过170的学生对象，放到一个新集合</span></span><br><span class="line">        List&lt;Student&gt; student1 = students.stream().filter(s -&gt; s.getHeight() &gt;= <span class="number">170</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(student1);</span><br><span class="line"></span><br><span class="line">        Set&lt;Student&gt; student2 = students.stream().filter(s -&gt; s.getHeight() &gt;= <span class="number">170</span>).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(student2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求5：找出身高超过170的学生对象并把学生的名字和身高，存入到一个Map集合中</span></span><br><span class="line">        Map&lt;String, Double&gt; map = students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">170</span>).distinct()</span><br><span class="line">                .collect(Collectors.toMap(Student::getName, Student::getHeight));</span><br><span class="line"></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;-----&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 收集到数组中</span></span><br><span class="line">        Object[] array = students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">170</span>).toArray();</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>siamFC测试自制数据集</title>
    <url>/2024/11/23/siamFC%E6%B5%8B%E8%AF%95%E8%87%AA%E5%88%B6%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h3 id="siamFC原理部分"><a href="#siamFC原理部分" class="headerlink" title="siamFC原理部分"></a>siamFC原理部分</h3><blockquote>
<p>通过学习siamFC的原理，download下来干净的跟踪源码，因为该算法是基于栾生网络的里程碑的单目标跟踪算法，故对于该算法进行复现，可参考<a href="https://www.bilibili.com/video/BV1ZZ4y1C7cm?spm_id_from=333.788.videopod.sections&vd_source=8f64217dbb5b2ca25035aff59cbda2b1">东大阿德的目标跟踪入门视频</a></p>
</blockquote>
<p><img src="/images/siamFC/1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>思想是将一个已知类别的训练样本和一个未知类别的测试样本分别输入到两个共享参数的 <code>CNN</code> 中。<br>从而获得两个特征向量，然后通过计算两个特征向量的 <code>相似度</code>，相似度越高表明其更可能是同一个类别。<br>使用了模板分支和搜索分支共享权重，模板分支实质上是第一帧提取的图像特征。<br>搜索分支与模板特征进行<code>滑动卷积</code>，最终输出一个得分图，得分最高的位置为当前帧的中心位置。缺点是缺乏对目标形状尺寸的感知度估计。</p>
</blockquote>
<p><img src="/images/siamFC/2.png" alt="OTB100"></p>
<blockquote>
<p>本来采用的测试集为OTB100数据集，但是组里的内容需要使用更高跟踪难度的飞行器目标进行测试。将自制的红外目标跟踪数据集作为测试数据集，权重采用GOT10k数据集训练的前2000个序列。</p>
</blockquote>
<hr>
<h3 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h3><blockquote>
<p>用来记录出现的问题和解决的方法。<br>首先在test.py程序中修改测试集合的路径。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root_dir = os.path.expanduser(<span class="string">&#x27;/home/ubuntu22/dataset/infread/OTB100&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单修改路径运行会发现跟踪还是会按照<code>OTB100</code>本来的序列信息进行寻找测试，又因为此时已经更改了数据集路径，所以肯定找不到会报错。</p>
</blockquote>
<p><img src="/images/siamFC/3.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>因此需要去更改读取数据集的序列处理函数的内容，位于<code>/anaconda3/envs/siamFC/lib/python3.7/site-packages/got10k/datasets</code>下面的<code>otb.py</code>文件。<br>注意，这里pycharm中有bug，如果只在pycharm中修改是无法生效的，用命令行的<code>vim</code>进行操作。发现test程序中传入的version&#x3D;2015,此时的序列信息为<code>__tb100_seqs </code> + <code>__tb50_seqs </code>的内容，所以需要更改序列信息。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__tb50_seqs = [<span class="string">&#x27;Basketball&#x27;</span>, <span class="string">&#x27;Biker&#x27;</span>, <span class="string">&#x27;Bird1&#x27;</span>, <span class="string">&#x27;BlurBody&#x27;</span>, <span class="string">&#x27;BlurCar2&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;BlurFace&#x27;</span>, <span class="string">&#x27;BlurOwl&#x27;</span>, <span class="string">&#x27;Bolt&#x27;</span>, <span class="string">&#x27;Box&#x27;</span>, <span class="string">&#x27;Car1&#x27;</span>, <span class="string">&#x27;Car4&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;CarDark&#x27;</span>, <span class="string">&#x27;CarScale&#x27;</span>, <span class="string">&#x27;ClifBar&#x27;</span>, <span class="string">&#x27;Couple&#x27;</span>, <span class="string">&#x27;Crowds&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Deer&#x27;</span>, <span class="string">&#x27;Diving&#x27;</span>, <span class="string">&#x27;DragonBaby&#x27;</span>, <span class="string">&#x27;Dudek&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;Football&#x27;</span>, <span class="string">&#x27;Freeman4&#x27;</span>, <span class="string">&#x27;Girl&#x27;</span>, <span class="string">&#x27;Human3&#x27;</span>, <span class="string">&#x27;Human4&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;Human6&#x27;</span>, <span class="string">&#x27;Human9&#x27;</span>, <span class="string">&#x27;Ironman&#x27;</span>, <span class="string">&#x27;Jump&#x27;</span>, <span class="string">&#x27;Jumping&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;Liquor&#x27;</span>, <span class="string">&#x27;Matrix&#x27;</span>, <span class="string">&#x27;MotorRolling&#x27;</span>, <span class="string">&#x27;Panda&#x27;</span>, <span class="string">&#x27;RedTeam&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;Shaking&#x27;</span>, <span class="string">&#x27;Singer2&#x27;</span>, <span class="string">&#x27;Skating1&#x27;</span>, <span class="string">&#x27;Skating2-1&#x27;</span>,<span class="string">&#x27;Skating2-2&#x27;</span>,<span class="string">&#x27;Skiing&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;Soccer&#x27;</span>, <span class="string">&#x27;Surfer&#x27;</span>, <span class="string">&#x27;Sylvester&#x27;</span>, <span class="string">&#x27;Tiger2&#x27;</span>, <span class="string">&#x27;Trellis&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;Walking&#x27;</span>, <span class="string">&#x27;Walking2&#x27;</span>, <span class="string">&#x27;Woman&#x27;</span>]</span><br><span class="line">__tb100_seqs = [<span class="string">&#x27;Bird2&#x27;</span>, <span class="string">&#x27;BlurCar1&#x27;</span>, <span class="string">&#x27;BlurCar3&#x27;</span>, <span class="string">&#x27;BlurCar4&#x27;</span>, <span class="string">&#x27;Board&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Bolt2&#x27;</span>, <span class="string">&#x27;Boy&#x27;</span>, <span class="string">&#x27;Car2&#x27;</span>, <span class="string">&#x27;Car24&#x27;</span>, <span class="string">&#x27;Coke&#x27;</span>, <span class="string">&#x27;Coupon&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Crossing&#x27;</span>, <span class="string">&#x27;Dancer&#x27;</span>, <span class="string">&#x27;Dancer2&#x27;</span>, <span class="string">&#x27;David2&#x27;</span>, <span class="string">&#x27;David3&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;Dog1&#x27;</span>, <span class="string">&#x27;Doll&#x27;</span>, <span class="string">&#x27;FaceOcc1&#x27;</span>, <span class="string">&#x27;FaceOcc2&#x27;</span>, <span class="string">&#x27;Fish&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;FleetFace&#x27;</span>, <span class="string">&#x27;Football1&#x27;</span>, <span class="string">&#x27;Freeman1&#x27;</span>, <span class="string">&#x27;Freeman3&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Girl2&#x27;</span>, <span class="string">&#x27;Gym&#x27;</span>, <span class="string">&#x27;Human2&#x27;</span>, <span class="string">&#x27;Human5&#x27;</span>, <span class="string">&#x27;Human7&#x27;</span>, <span class="string">&#x27;Human8&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Jogging-1&#x27;</span>,<span class="string">&#x27;Jogging-2&#x27;</span>,<span class="string">&#x27;KiteSurf&#x27;</span>, <span class="string">&#x27;Lemming&#x27;</span>, <span class="string">&#x27;Man&#x27;</span>, <span class="string">&#x27;Mhyang&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;MountainBike&#x27;</span>, <span class="string">&#x27;Rubik&#x27;</span>, <span class="string">&#x27;Singer1&#x27;</span>, <span class="string">&#x27;Skater&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Skater2&#x27;</span>, <span class="string">&#x27;Subway&#x27;</span>, <span class="string">&#x27;Suv&#x27;</span>, <span class="string">&#x27;Tiger1&#x27;</span>, <span class="string">&#x27;Toy&#x27;</span>, <span class="string">&#x27;Trans&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Twinnings&#x27;</span>, <span class="string">&#x27;Vase&#x27;</span>] + __tb50_seqs</span><br><span class="line"></span><br><span class="line">				__otb15_seqs = __tb100_seqs</span><br><span class="line">__version_dict = &#123;</span><br><span class="line">       <span class="number">2013</span>: __otb13_seqs,</span><br><span class="line">       <span class="number">2015</span>: __otb15_seqs,</span><br><span class="line">       <span class="string">&#x27;otb2013&#x27;</span>: __otb13_seqs,</span><br><span class="line">       <span class="string">&#x27;otb2015&#x27;</span>: __otb15_seqs,</span><br><span class="line">       <span class="string">&#x27;tb50&#x27;</span>: __tb50_seqs,</span><br><span class="line">       <span class="string">&#x27;tb100&#x27;</span>: __tb100_seqs&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自制的数据集序列为<code>data001-data020</code>，所以更改这一部分为：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__tbInfread_seqs = [</span><br><span class="line">       <span class="string">&#x27;data001&#x27;</span>, <span class="string">&#x27;data002&#x27;</span>, <span class="string">&#x27;data003&#x27;</span>, <span class="string">&#x27;data004&#x27;</span>, <span class="string">&#x27;data005&#x27;</span>, <span class="string">&#x27;data006&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;data007&#x27;</span>, <span class="string">&#x27;data008&#x27;</span>, <span class="string">&#x27;data009&#x27;</span>, <span class="string">&#x27;data010&#x27;</span>, <span class="string">&#x27;data011&#x27;</span>, <span class="string">&#x27;data012&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;data013&#x27;</span>, <span class="string">&#x27;data014&#x27;</span>, <span class="string">&#x27;data015&#x27;</span>, <span class="string">&#x27;data016&#x27;</span>, <span class="string">&#x27;data017&#x27;</span>, <span class="string">&#x27;data018&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;data019&#x27;</span>, <span class="string">&#x27;data020&#x27;</span>]</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 尝试修改</span></span><br><span class="line">   <span class="comment"># __otb15_seqs = __tb100_seqs</span></span><br><span class="line">   __otb15_seqs = __tbInfread_seqs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>另外发现自制的红外小目标数据集里的data004中的groundtruth.txt文件标注信息格式有误,有多余的<code>[]</code>，报错:</p>
</blockquote>
<p><img src="/images/siamFC/4.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>使用命令批量操作:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\[//g; s/\]//g&#x27; groundtruth_rect.txt</span><br></pre></td></tr></table></figure>
<p>至此全部解决,成功复现siamFC算法在自制的红外目标小数据集上测试.<br><img src="/images/siamFC/5.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>单目标跟踪</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>单目标跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title>西电高性能计算实验-基于CUDA加速的卡尔曼滤波算法</title>
    <url>/2024/12/01/%E8%A5%BF%E7%94%B5%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C-%E5%9F%BA%E4%BA%8ECUDA%E5%8A%A0%E9%80%9F%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><ul>
<li>GPU型号：NAVIDIA GeForce  MX350</li>
<li>运行环境 wsl2-ubuntu22.04</li>
<li>使用语言：CUDA c++</li>
<li>CPU型号：i5-10210U 4核, 1.60GHz</li>
</ul>
<hr>
<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><blockquote>
<p>卡尔曼滤波算法是一种利用线性系统状态方程，通过系统输入观测数据、上一状态的信息，对系统当前状态进行最优估计的算法。卡尔曼滤波器与大多数滤波器不同之处，在于它是一种纯粹的时域滤波器，它不需要像低通滤波器等频域滤波器那样，需要在频域设计再转换到时域实现。</p>
</blockquote>
<blockquote>
<p>卡尔曼滤波器包括两个主要阶段：预测阶段和更新阶段。在每次迭代中，这两个阶段涉及18次矩阵操作，包括矩阵加法、减法、转置、乘法和逆运算。其中矩阵乘法和逆运算计算量较大。</p>
</blockquote>
<h4 id="卡尔曼滤波算法中涉及的矩阵操作如下："><a href="#卡尔曼滤波算法中涉及的矩阵操作如下：" class="headerlink" title="卡尔曼滤波算法中涉及的矩阵操作如下："></a>卡尔曼滤波算法中涉及的矩阵操作如下：</h4><table border="1">
  <thead>
    <tr>
      <th>Matrix Operation</th>
      <th>Equation</th>
      <th>Size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Multiply</td>
      <td>x<sub>k</sub><sup>-</sup> = F * x<sub>k-1</sub></td>
      <td>(ns * ns) x (ns * 1)</td>
    </tr>
    <tr>
      <td>Transpose</td>
      <td>F<sup>T</sup></td>
      <td>(ns * ns)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>P<sub>k-1</sub> * F<sup>T</sup></td>
      <td>(ns * ns) x (ns * ns)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>F * P<sub>k-1</sub> * F<sup>T</sup></td>
      <td>(ns * ns) x (ns * ns)</td>
    </tr>
    <tr>
      <td>Add</td>
      <td>P<sub>k</sub><sup>-</sup> = F * P<sub>k-1</sub> * F<sup>T</sup> + Q</td>
      <td>(ns * ns) + (ns * ns)</td>
    </tr>
    <tr>
      <td>Transpose</td>
      <td>H<sup>T</sup></td>
      <td>(no * ns)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>P<sub>k</sub><sup>-</sup> * H<sup>T</sup></td>
      <td>(ns * ns) x (ns * no)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>H * P<sub>k</sub><sup>-</sup> * H<sup>T</sup></td>
      <td>(no * ns) x (ns * no)</td>
    </tr>
    <tr>
      <td>Add</td>
      <td>H * P<sub>k</sub><sup>-</sup> * H<sup>T</sup> + E</td>
      <td>(no * no) + (no * no)</td>
    </tr>
    <tr>
      <td>Inverse</td>
      <td>(H * P<sub>k</sub><sup>-</sup> * H<sup>T</sup> + E)<sup>-1</sup></td>
      <td>(no * no)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>P<sub>k</sub><sup>-</sup> * H<sup>T</sup> * (H * P<sub>k</sub><sup>-</sup> * H<sup>T</sup> + E)<sup>-1</sup></td>
      <td>(ns * no) x (no * no)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>H * x<sub>k</sub></td>
      <td>(no * ns) x (ns * 1)</td>
    </tr>
    <tr>
      <td>Subtract</td>
      <td>z<sub>k</sub> - H * x<sub>k</sub><sup>-</sup></td>
      <td>(no * 1) - (no * 1)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>K<sub>k</sub> * (z<sub>k</sub> - H * x<sub>k</sub><sup>-</sup>)</td>
      <td>(ns * no) x (no * 1)</td>
    </tr>
    <tr>
      <td>Add</td>
      <td>x<sub>k</sub> = x<sub>k</sub><sup>-</sup> + K<sub>k</sub> * (z<sub>k</sub> - H * x<sub>k</sub><sup>-</sup>)</td>
      <td>(ns * 1) + (ns * 1)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>K<sub>k</sub> * H</td>
      <td>(ns * no) x (no * ns)</td>
    </tr>
    <tr>
      <td>Subtract</td>
      <td>I - K<sub>k</sub> * H</td>
      <td>(ns * ns) - (ns * ns)</td>
    </tr>
    <tr>
      <td>Multiply</td>
      <td>(I - K<sub>k</sub> * H) * P<sub>k</sub><sup>-</sup></td>
      <td>(ns * ns) x (ns * ns)</td>
    </tr>
  </tbody>
</table>

<blockquote>
<p>GPU（通用计算在图形处理单元上的应用）指的是利用GPU的强大并行计算能力进行传统CPU处理之外的计算任务。在过去，GPU主要用于图形渲染，但随着计算需求的多样化，GPU也逐渐被用于处理各种高并行性的计算任务。通过利用CUDA等技术，GPU能够显著提高计算效率，特别是在大规模数据处理和数值计算方面。</p>
</blockquote>
<ul>
<li><h2 id="CPU和GPU结构图："><a href="#CPU和GPU结构图：" class="headerlink" title="CPU和GPU结构图：  "></a>CPU和GPU结构图：<br>  <img src="/images/highExpeiment/linux/image-7.png" alt="alt text"></h2>  <img src="/images/highExpeiment/linux/image-6.png" alt="alt text"></li>
</ul>
<hr>
<blockquote>
<p>CUDA（Compute Unified Device Architecture）是由NVIDIA开发的一个并行计算平台和编程模型，允许开发者利用GPU进行通用计算。与传统的CPU架构不同，CUDA架构通过数百或数千个小型处理单元（线程）来并行处理数据，从而加速计算任务。CUDA支持C、C++等编程语言，使得开发者能够方便地在GPU上实现并行算法。</p>
</blockquote>
<blockquote>
<p>我们通过CUDA编程语言探索将矩阵操作并行化的可能性。本次实验采用共享内存优化矩阵乘法，并使用Cholesky分解算法处理矩阵逆运算（因其高效性）。此外，我们将在CPU和GPU上分别实现卡尔曼滤波器，并对两种实现的执行时间进行比较，分析GPU加速效果在不同输入规模下的表现。</p>
</blockquote>
<hr>
<h4 id="卡尔曼状态转移公式："><a href="#卡尔曼状态转移公式：" class="headerlink" title="卡尔曼状态转移公式："></a>卡尔曼状态转移公式：</h4><blockquote>
<p><img src="/images/highExpeiment/linux/image.png" alt="alt text"></p>
</blockquote>
<ul>
<li>预测阶段：<ul>
<li><strong>状态预测：</strong></li>
<li><img src="/images/highExpeiment/linux/image-1.png" alt="alt text"></li>
<li><strong>状态协方差预测：</strong></li>
<li><img src="/images/highExpeiment/linux/image-2.png" alt="alt text"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>更新阶段：</p>
<ul>
<li><strong>卡尔曼增益：</strong></li>
<li><img src="/images/highExpeiment/linux/image-3.png" alt="alt text"></li>
<li><strong>状态更新：</strong></li>
<li><img src="/images/highExpeiment/linux/image-4.png" alt="alt text"></li>
<li><strong>协方差更新：</strong></li>
<li><img src="/images/highExpeiment/linux/image-5.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="卡尔曼滤波器并行计算理论分析"><a href="#卡尔曼滤波器并行计算理论分析" class="headerlink" title="卡尔曼滤波器并行计算理论分析"></a>卡尔曼滤波器并行计算理论分析</h3><ul>
<li>预测阶段<blockquote>
<p>在预测阶段，我们根据上一时刻的状态估计和输入控制量计算出当前时刻的状态预测。在CUDA实现中，我们将矩阵乘法和加法操作并行化，每个线程负责计算一个矩阵元素。    </p>
</blockquote>
</li>
<li>更新阶段<blockquote>
<p>在更新阶段，我们首先计算卡尔曼增益，并根据测量更新状态估计。在GPU实现中，卡尔曼增益的计算和状态更新是通过并行计算多个矩阵元素的方式加速的。矩阵的逆运算通过Cholesky分解进行优化，以减少计算复杂度。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="进行实验"><a href="#进行实验" class="headerlink" title="进行实验"></a>进行实验</h2><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><blockquote>
<p>考虑编写代码，为了实现CUDA加速卡尔曼滤波算法，要设计<code>kalman.cu</code>函数，并使用CUDA并行计算技术加速卡尔曼滤波算法。<br>CUDA 的并行化通过网格和线程块实现。在其中的 ｀PredictKernel｀ 和 ｀UpdateKernel｀函数中 中，利用每个线程负责一个小任务（如计算矩阵的一个元素），通过并行执行实现加速。</p>
</blockquote>
<ul>
<li><p>实现矩阵乘法函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__device__ <span class="type">float</span> <span class="title">ele_multi</span><span class="params">(<span class="type">float</span>* A, <span class="type">float</span>* B, <span class="type">int</span> Awidth, <span class="type">int</span> Bwidth, <span class="type">int</span> tx, <span class="type">int</span> ty)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> Pvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; Awidth; ++k) &#123;</span><br><span class="line">        <span class="type">float</span> Melement = A[ty * Awidth + k];</span><br><span class="line">        <span class="type">float</span> Nelement = B[k * Bwidth + tx];</span><br><span class="line">        Pvalue += Melement * Nelement;  <span class="comment">// 按行和列计算矩阵的一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码中每个线程通过 (tx, ty) 定位到对应矩阵的一个元素位置。使用循环遍历矩阵的中间维度，并将结果累计到 Pvalue</p>
</blockquote>
</li>
<li><p>实现预测值和协方差矩阵的并行计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">PredictKernel</span><span class="params">(<span class="type">float</span>* predictD, <span class="type">float</span>* covD, <span class="type">float</span>* new_predictD, <span class="type">float</span>* new_covD, <span class="type">int</span> point_num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tx = threadIdx.x;</span><br><span class="line">    <span class="type">int</span> ty = threadIdx.y;</span><br><span class="line">    <span class="type">int</span> bx = blockIdx.x;</span><br><span class="line"></span><br><span class="line">    __shared__ <span class="type">float</span> temp[CovSize];  <span class="comment">// 共享内存用于存储中间结果</span></span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算预测值 A * predict</span></span><br><span class="line">    <span class="keyword">if</span> (tx == <span class="number">0</span>) &#123;</span><br><span class="line">        value = <span class="built_in">ele_multi</span>(A, predictD + bx * PredictSize, <span class="number">4</span>, <span class="number">1</span>, tx, ty);</span><br><span class="line">        new_predictD[bx * PredictSize + ty] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算协方差 A * cov</span></span><br><span class="line">    value = <span class="built_in">ele_multi</span>(A, covD + bx * CovSize, <span class="number">4</span>, <span class="number">4</span>, tx, ty);</span><br><span class="line">    temp[ty * <span class="number">4</span> + tx] = value;</span><br><span class="line"></span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最终协方差 (A * cov) * AT + Q</span></span><br><span class="line">    value = <span class="built_in">ele_multi</span>(temp, AT, <span class="number">4</span>, <span class="number">4</span>, tx, ty);</span><br><span class="line">    <span class="keyword">if</span> (bx &lt; point_num) &#123;</span><br><span class="line">        new_covD[bx * CovSize + ty * <span class="number">4</span> + tx] = value + Q[ty * <span class="number">4</span> + tx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键点在于使用 <code>__shared__</code> 缓存中间结果，减少全局内存访问和<code>ele_multi</code> 函数分摊矩阵的计算量到各线程中。</p>
</blockquote>
</li>
<li><p>内存优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__constant__ <span class="type">float</span> A[<span class="number">16</span>] = &#123;<span class="number">1.0</span>, <span class="number">0</span>, Time, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0</span>, Time, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">__constant__ <span class="type">float</span> Q[<span class="number">16</span>] = &#123;<span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.002</span>, <span class="number">0.01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.001</span>&#125;;</span><br><span class="line"></span><br><span class="line">__shared__ <span class="type">float</span> temp[CovSize];  <span class="comment">// 定义共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用共享内存存储协方差中间结果</span></span><br><span class="line">value = <span class="built_in">ele_multi</span>(A, covD + bx * CovSize, <span class="number">4</span>, <span class="number">4</span>, tx, ty);</span><br><span class="line">temp[ty * <span class="number">4</span> + tx] = value;</span><br><span class="line"></span><br><span class="line">__syncthreads();  <span class="comment">// 同步线程，确保共享内存中的数据已被计算</span></span><br><span class="line"><span class="comment">// 计算最终协方差 (A * cov) * AT + Q</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CUDA 使用 共享内存 和 常量内存 加速矩阵操作，减少频繁的全局内存访问开销。<code>A</code> 和 <code>Q</code> 是常用的状态转移矩阵和噪声协方差矩阵，放在常量内存中，所有线程共享。</p>
</blockquote>
</li>
<li><p>异步优化及流的使用</p>
<blockquote>
<p>主函数中的 predict_loop 使用异步操作和 CUDA 流，提高了主机和设备之间的数据传输效率：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">predict_loop</span><span class="params">(<span class="type">int</span> iteration_num, <span class="type">float</span>* predict, <span class="type">float</span>* cov, <span class="type">float</span>* new_predict, <span class="type">float</span>* new_cov, <span class="type">int</span> point_num, <span class="type">float</span> <span class="type">delta_t</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> *predictD, *covD, *new_predictD, *new_covD;</span><br><span class="line">    cudaStream_t stream; </span><br><span class="line">    <span class="built_in">cudaStreamCreate</span>(&amp;stream);  <span class="comment">// 创建一个 CUDA 流</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在设备上分配内存</span></span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;predictD, PredictSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;covD, CovSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;new_predictD, PredictSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;new_covD, CovSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步将数据拷贝到设备</span></span><br><span class="line">    <span class="built_in">cudaMemcpyAsync</span>(predictD, predict, PredictSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice, stream);</span><br><span class="line">    <span class="built_in">cudaMemcpyAsync</span>(covD, cov, CovSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice, stream);</span><br><span class="line"></span><br><span class="line">    <span class="function">dim3 <span class="title">dimBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;  <span class="comment">// 定义线程块大小</span></span><br><span class="line">    <span class="function">dim3 <span class="title">dimGrid</span><span class="params">((point_num + dimBlock.x - <span class="number">1</span>) / dimBlock.x, <span class="number">1</span>)</span></span>;  <span class="comment">// 定义网格大小</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步流</span></span><br><span class="line">    <span class="built_in">cudaStreamSynchronize</span>(stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝结果回主机</span></span><br><span class="line">    <span class="built_in">cudaMemcpyAsync</span>(new_predict, new_predictD, PredictSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost, stream);</span><br><span class="line">    <span class="built_in">cudaMemcpyAsync</span>(new_cov, new_covD, CovSize * point_num * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost, stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存和销毁流</span></span><br><span class="line">    <span class="built_in">cudaStreamDestroy</span>(stream);</span><br><span class="line">    <span class="built_in">cudaFree</span>(predictD);</span><br><span class="line">    <span class="built_in">cudaFree</span>(covD);</span><br><span class="line">    <span class="built_in">cudaFree</span>(new_predictD);</span><br><span class="line">    <span class="built_in">cudaFree</span>(new_covD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 cudaMemcpyAsync 和流，主机和设备数据传输可与计算并行。dimBlock 和 dimGrid 根据问题规模动态调整，保证每个线程块的 GPU 核心负载均匀。<br>并且这里自己在进行调试实验时dimBlock和dimGrid的参数设置不正确，GPU利用率低，导致计算效率低下。</p>
</blockquote>
</li>
<li><p>与CPU对比</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpu_matrix_multiply</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* A, <span class="type">const</span> <span class="type">float</span>* B, <span class="type">float</span>* C, <span class="type">int</span> rowsA, <span class="type">int</span> colsA, <span class="type">int</span> colsB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowsA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colsB; j++) &#123;</span><br><span class="line">            C[i * colsB + j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; colsA; k++) &#123;</span><br><span class="line">                C[i * colsB + j] += A[i * colsA + k] * B[k * colsB + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><blockquote>
<p>在ubuntu上将代码进行编译，这里采用<code>nvcc -O3 -arch=sm_52 -o</code>的编译方式，使得GPU利用率达到100%。</p>
</blockquote>
<p><img src="/images/highExpeiment/linux/image-8.png" alt="alt text"></p>
<blockquote>
<p>进行多组实验<br>重新编写test程序，设置多组点数和迭代次数，记录执行时间：分别执行 CPU 和 CUDA 版本的卡尔曼滤波，记录时间及其加速比。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置多组实验的参数</span></span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; iteration_nums = &#123;<span class="number">10000</span>, <span class="number">100000</span>&#125;;  <span class="comment">// 迭代次数</span></span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; points_nums = &#123;<span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>&#125;;  <span class="comment">// 点数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果如下：<br><img src="/images/highExpeiment/linux/image-9.png" alt="alt text"></p>
</blockquote>
<h3 id="最终实验结果表"><a href="#最终实验结果表" class="headerlink" title="最终实验结果表"></a>最终实验结果表</h3><table>
<thead>
<tr>
<th>迭代次数</th>
<th>点数</th>
<th>CUDA 执行时间 (秒)</th>
<th>CPU 执行时间 (秒)</th>
<th>加速比</th>
</tr>
</thead>
<tbody><tr>
<td>10000</td>
<td>1000</td>
<td>1.41731</td>
<td>0.170273</td>
<td>0.120138</td>
</tr>
<tr>
<td>10000</td>
<td>10000</td>
<td>0.0075278</td>
<td>1.90203</td>
<td>252.668</td>
</tr>
<tr>
<td>10000</td>
<td>100000</td>
<td>0.0045187</td>
<td>34.3827</td>
<td>7608.97</td>
</tr>
<tr>
<td>100000</td>
<td>1000</td>
<td>0.0345809</td>
<td>1.04672</td>
<td>30.2688</td>
</tr>
<tr>
<td>100000</td>
<td>10000</td>
<td>0.0403174</td>
<td>18.6727</td>
<td>463.143</td>
</tr>
<tr>
<td>100000</td>
<td>100000</td>
<td>0.0394984</td>
<td>341.291</td>
<td>8640.62</td>
</tr>
</tbody></table>
<hr>
<h3 id="数据分析总结："><a href="#数据分析总结：" class="headerlink" title="数据分析总结："></a>数据分析总结：</h3><blockquote>
<ul>
<li>1.GPU 的优势在大数据集和高迭代次数时表现最为明显：当数据集较大（如 10000 和 100000 点），并且迭代次数增加时，GPU 的并行计算优势显著。GPU 的加速比在大数据集上有显著提升，尤其在 100000 点 和 100000 次迭代 时，GPU 展现了 极高的加速比</li>
<li>2.对于小规模数据集（如 1000 点）：GPU 相对于 CPU 的加速比极低，甚至低于 1，这可能是因为数据量太小，GPU 并行计算的优势未能完全发挥出来。此时，CPU 更适合执行这类小规模计算任务。</li>
<li>3.在高迭代次数的情况下：即使是较小的数据集，随着迭代次数的增多，GPU 的加速优势也开始显现。尤其在 100000 次迭代 的情况下，GPU 的执行时间大大低于 CPU。</li>
</ul>
</blockquote>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结:"></a>实验总结:</h3><blockquote>
<p>本文使用 CUDA 实现了并行计算版本的卡尔曼滤波器，并对比了 CPU 和 GPU 的执行时间。实验结果表明：在大数据集和高迭代次数的情况下，GPU 的加速比更加理想。</p>
</blockquote>
<hr>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul>
<li>[1] An Introduction to the Kalman Filter by Greg Welch and Gary Bishop.</li>
<li>[2] <a href="http://en.wikipedia.org/wiki/Kalman_filter">http://en.wikipedia.org/wiki/Kalman_filter</a></li>
<li>[3] <a href="http://en.wikipedia.org/wiki/GPGPU">http://en.wikipedia.org/wiki/GPGPU</a></li>
<li>[4] <a href="http://www.nvidia.com/object/what-is-gpu-computing.html">http://www.nvidia.com/object/what-is-gpu-computing.html</a></li>
<li>[5] GPGPU origins and GPU hardware architecture by Stephan Soller</li>
<li>[6] <a href="http://en.wikipedia.org/wiki/CUDA">http://en.wikipedia.org/wiki/CUDA</a></li>
<li>[7] Matrix Multiplication with CUDA-A basic introduction to the CUDA    programming model by Robert Hochberg.</li>
</ul>
]]></content>
      <tags>
        <tag>CUDA加速</tag>
        <tag>GPU应用</tag>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
</search>
