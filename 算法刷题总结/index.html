
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>pinguier&#39;s blog - 想转码的通信菜狗</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="pinguier,"> 
    <meta name="description" content="垂直活着 水平留恋着,"> 
    <meta name="author" content="pinguier"> 
    <link rel="alternative" href="atom.xml" title="pinguier&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="pinguier&#39;s blog - 想转码的通信菜狗"/>
    <meta name="twitter:description" content="垂直活着 水平留恋着,"/>
    
    
    
    
    <meta property="og:site_name" content="pinguier&#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="pinguier&#39;s blog - 想转码的通信菜狗"/>
    <meta property="og:description" content="垂直活着 水平留恋着,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.3.0"></head>

<canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>

<body class="loading">
    <span id="config-title" style="display:none">pinguier&#39;s blog</span>
    <div id="loader"></div>
    <div id="single" class="page">
    <div id="top">
        <a class="iconfont icon-left image-icon" href="javascript:history.back()"></a>
    </div>
    <div class="section">
        <div class="article">
            <div class="main">
                <div class="content">
                
                        <h1 id="算法刷题总结"><a href="#算法刷题总结" class="headerlink" title="算法刷题总结"></a>算法刷题总结</h1><hr>
<h2 id="一些算法对应的题目练习"><a href="#一些算法对应的题目练习" class="headerlink" title="一些算法对应的题目练习"></a>一些算法对应的题目练习</h2><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><ul>
<li><p>荷兰国旗问题： 只能线性扫描一遍，将数组排好序。</p>
</li>
<li><p>题目：<code>leetcode T75</code></p>
</li>
<li><p>思路：用三个指针 <code>i j k</code>来维护这段区间，保证满足的性质：<code>[0,j-1]</code>为0，<code>[j, i-1]</code>为1，<code>[k+1, n-1]</code>为2，一开始当<code>i j</code>为0，k为n-1时，该性质满足，用<code>i</code>来遍历整个数组，<code>i</code>分为三种情况：a[i]为0，根据前面提到的维护性质有a[j]一定为1,此时需要交换a[i]和a[j]，交换后a[j]变成了0,所以此时需要将j向前移动，再继续扫描，所以将i+1;如果a[i]为2，要知道性质是<code>[k+1,n-1]</code>才为2的，所以此时需要交换a[k]和a[i]，并且交换后a[k]变成了2，所以要将k–,但是，对于交换后的a[i]，无法判断a[i]此时是0还是1还是2，所以i不会移动，继续判断a[i]的值；最后，如果a[i]等于1，本来要满足的性质就是<code>[j, i - 1]</code>为1，所以此时将i向前移动，让a[i - 1]变成新的1.</p>
<p><img src="C:\learningNotes\image-20241014163906714.png" alt="image-20241014163906714"></p>
</li>
</ul>
<p>​</p>
<h3 id="岛屿问题-Floodfill算法"><a href="#岛屿问题-Floodfill算法" class="headerlink" title="岛屿问题 Floodfill算法"></a>岛屿问题 <code>Floodfill</code>算法</h3><ul>
<li>题目： <code>leetcode T200 T1254 T1020 T1905 T695 T1992</code></li>
<li>参考自己写的博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62404686/article/details/143117520?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_62404686/article/details/143117520?spm=1001.2014.3001.5501</a></li>
</ul>
<hr>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li><p>代码模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">window</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        window.add(c)</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">// ***********************</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            window.remove(d)</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>题目 <code>leetcode T76 T567 T3</code></p>
</li>
<li><p>分析 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/sliding-window-framework/#%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">https://labuladong.online/algo/essential-technique/sliding-window-framework/#%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2</a></p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; windows = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; needs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: t.toCharArray()) &#123;</span><br><span class="line">            needs.put(c, needs.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right++);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(needs.containsKey(c)) &#123;</span><br><span class="line">                windows.put(c, windows.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(needs.get(c).equals(windows.get(c)))</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; valid == needs.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left++);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(needs.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(needs.get(d).equals(windows.get(d)))</span><br><span class="line">                        valid--;</span><br><span class="line"></span><br><span class="line">                    windows.put(d, windows.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h3><ul>
<li>题目 ：<code>leetcode</code>: 41、442</li>
</ul>
<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p><code>leetcode :</code> 42 总体思想： 按列拆分</p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240921214612646.png" alt="image-20240921214612646"></p>
<ul>
<li><p>核心是采用线性扫描三次的方式，存储当前位置<code>i</code>左边最高的柱子和右边最高的柱子。对于当前<code>i</code>位置的柱子，所存储的雨水为<code>min(l_max[i], r_max[i]) - height[i]</code></p>
</li>
<li><p>细节方面需要注意：更新l_max[i] 需要包含当前柱子的高度，同理r_max[i]也需要包含当前柱子的高度。倘若当前柱子的高度是全场最高，那么当前位置的柱子就无法存储雨水。</p>
</li>
<li><p>初始化base case是l_max[0] &#x3D; height[0] r_max[n - 1] &#x3D; height[n - 1],并且l_max从左向右遍历，r_max从右向左遍历。</p>
</li>
</ul>
<hr>
<h3 id="高精度算法（加法乘法）"><a href="#高精度算法（加法乘法）" class="headerlink" title="高精度算法（加法乘法）"></a>高精度算法（加法乘法）</h3><p>题目：</p>
<ul>
<li><p><code>leetcode 44</code> 高精度乘法</p>
</li>
<li><p>高精度加法  <code>leetcode 415  66 67</code></p>
<ul>
<li><p>模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; A = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; B = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.add(a.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.add(b.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; C = add(A, B);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(C.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 高精度加法模板</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; A.size()) t += A.get(i);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; B.size()) t += B.get(i);</span><br><span class="line">            C.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="数组的花样遍历"><a href="#数组的花样遍历" class="headerlink" title="数组的花样遍历"></a>数组的花样遍历</h3><ul>
<li><h4 id="翻转问题-找规律类"><a href="#翻转问题-找规律类" class="headerlink" title="翻转问题(找规律类)"></a>翻转问题(找规律类)</h4><ul>
<li>对于行列相等的矩阵：<ul>
<li>顺时针 90： 主对角线（从左上到右下）翻转，然后从中间水平反转</li>
<li>逆时针 90： 主对角线翻转，然后从中间上下翻转</li>
<li>顺时针180和逆时针180 都是先主对角线翻转，然后副对角线翻转题目： <code>leecode T48</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="螺旋遍历"><a href="#螺旋遍历" class="headerlink" title="螺旋遍历"></a>螺旋遍历</h4><ul>
<li>根据规定好的方向(方向数组遍历)，每次更新遍历到下一次的坐标结果</li>
<li>题目： <code>leetcode T54 T59</code></li>
</ul>
</li>
<li><p>旋转链表</p>
<ul>
<li><p>题目 <code>leetcode T61</code></p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20241006150655238.png" alt="image-20241006150655238"></p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录链表中的元素个数</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            tail = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">// 力扣经典操作</span></span><br><span class="line">        k %= n; <span class="comment">// 对于k很大的情况 旋转n次相等于没有变化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = head; <span class="comment">// 原先的尾节点指向头节点</span></span><br><span class="line">        head = p.next; <span class="comment">// 新的头节点变成倒数第k个节点</span></span><br><span class="line">        p.next = <span class="literal">null</span>; <span class="comment">// 全部的k个节点向前移动 该位置变成空节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="字母异位组"><a href="#字母异位组" class="headerlink" title="字母异位组"></a>字母异位组</h3><ul>
<li>思路 ： 将排序后的字符串作为哈希表的键存储</li>
<li>题目 <code>leetcode T49 T242</code></li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul>
<li><p>题目 <code>leetcode T53</code></p>
<h5 id="类型1：线性dp"><a href="#类型1：线性dp" class="headerlink" title="类型1：线性dp "></a>类型1：线性<code>dp </code></h5><ul>
<li><p>题目：<code>acwing 摘花生</code> <code>leetcode T62 T63 T64 T70</code></p>
</li>
<li><p>分析 <img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20241006160036722.png" alt="image-20241006160036722"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3><p>对于两个字符串，进行三种操作(增删改)，求一个串变成另一个串需要的最小步骤</p>
<ul>
<li><p>题目: <code>acwing 899 902</code> <code>leetcode T72</code></p>
</li>
<li><p>分析：</p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20241012171942762.png" alt="image-20241012171942762"></p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                f[i][j] = Math.min(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) f[i][j] = Math.min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j]);</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = Math.min(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, f[i][j]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="排列-组合-子集问题"><a href="#排列-组合-子集问题" class="headerlink" title="排列 组合 子集问题"></a>排列 组合 子集问题</h3><ul>
<li><p>常规的全排列问题 一般写法是回溯写法 如<code>leetcode T46和 T47</code>,  二者的区别在于是否有重复，对于无重复的写法一般代码结构如下：</p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20241005223930081.png" alt="image-20241005223930081"></p>
<p>对于有重复的不复选全排列问题，为了防止选到重复元素，要添加判断的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>; <span class="comment">// 保证不复选 通过i的位置 而不是通过nums[i]的值 因为nums[i]中有重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="排列组合问题"><a href="#排列组合问题" class="headerlink" title="排列组合问题"></a>排列组合问题</h3><ul>
<li><p>对于回溯算法时间复杂度过高的特殊排列问题，如<code>leetcode T60</code>,提供了一种新型的对于求满足字典序的第k个排列问题的方法，时间复杂度可以优化到O(n ^ 2),其写法非常巧妙，值得钻研，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span>[] st = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// n个数枚举n个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fact</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 求当前第i个数确定后还有多少种排列 排列的个数为：[n - (i + 1)]!</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n - i - <span class="number">1</span>; j++) fact = fact * j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 枚举第i位放第值为j这个数 也就是从1到n里面选一个数放在位置为第i个数的位置上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 首先要保证j这个数没有被i位置前面的数所用到</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">                    <span class="comment">// 如果枚举到第i个位置时，还能放的排列个数小于以字典序为顺序的第k个排列</span></span><br><span class="line">                    <span class="keyword">if</span>(fact &lt; k) k -= fact; <span class="comment">// 说明第k个排列时第i个位置不放j这个数，第i个位置应该放的数比j大</span></span><br><span class="line">                    <span class="comment">//// 说明第k个排列时第i个位置放j这个数</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        res = res + <span class="string">&quot;&quot;</span>+ j;</span><br><span class="line">                        st[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 第i个位置的数已经确定是j了，就不能选择别的了，所以break掉循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><ul>
<li>模板在下方</li>
<li>题目 <code>leetcode T31 T33 T34 T35</code></li>
</ul>
<h4 id="浮点数二分-简单"><a href="#浮点数二分-简单" class="headerlink" title="浮点数二分(简单)"></a>浮点数二分(简单)</h4><ul>
<li>题目 <code>leetcode T69</code></li>
</ul>
<h3 id="恶心的模拟题"><a href="#恶心的模拟题" class="headerlink" title="恶心的模拟题"></a>恶心的模拟题</h3><ul>
<li>题目<ul>
<li><code>leetcode T65 T68</code></li>
</ul>
</li>
</ul>
<h3 id="数据结构解题"><a href="#数据结构解题" class="headerlink" title="数据结构解题"></a>数据结构解题</h3><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><ul>
<li>题目： <code>leetcode T71</code></li>
</ul>
<hr>
<h3 id="归并排序-重点是学习思想"><a href="#归并排序-重点是学习思想" class="headerlink" title="归并排序  重点是学习思想"></a>归并排序  重点是学习思想</h3><p>解决问题：将两个有序的数组合并成一个有序数组 合二为一</p>
<p>思路：两个数组从最小&#x2F;最大开始比较，开辟一个新的数组用于存放新合并的数组，哪个更小放哪个，并依次指针后移。</p>
<p>时间复杂度：<code>O(nlogn)</code></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> q[N],temp[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1.确定分界点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.递归两侧的区间</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid),<span class="built_in">merge_sort</span>(mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="comment">//进行归并</span></span><br><span class="line">    <span class="type">int</span> i = l,j = mid<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) temp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,k=<span class="number">0</span>;i&lt;=r;i++,k++) q[i] = temp[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h3 id="面试题-leetcode-T-88"><a href="#面试题-leetcode-T-88" class="headerlink" title="面试题 leetcode T.88"></a><code>面试题 leetcode T.88</code></h3><p>![&#96;](C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240726111521866.png)</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>本题中的<code>nums1</code>数组开辟的空间很大且正好为<code>n+m</code>的长度，因此可以将归并后的<code>nums2</code>中的元素直接合并到<code>nums1</code>,但是由于归并后是非递减序，因此归并时应该从右边开始，防止覆盖掉左边的元素，故归并时应该比较两个数组中的较大的元素，哪个大就放到<code>nums1</code>的右边，然后进行指针移动，最后将剩余的数组中的元素按照从右往左的顺序放入到 <code>nums1</code>中。</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = n + m - <span class="number">1</span>;<span class="comment">//确定从哪一个开始放入合并后的元素位置</span></span><br><span class="line">        <span class="type">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt;= nums2[j]) nums1[k--] = nums1[i--];</span><br><span class="line">            <span class="keyword">else</span> nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) nums1[k--] = nums1[i--];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="格雷码问题-leetcode-T89"><a href="#格雷码问题-leetcode-T89" class="headerlink" title="格雷码问题 leetcode T89"></a>格雷码问题 <code>leetcode T89</code></h4><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240726120416712.png" alt="image-20240726120416712"></p>
<h4 id="构造格雷码"><a href="#构造格雷码" class="headerlink" title="构造格雷码"></a>构造格雷码</h4><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240726120359991.png" alt="image-20240726120359991"></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>规律：在上一个结果的基础上进行上下翻转，然后上半部分补0，下半部分补1</p>
<p>操作：补0等价于在原来数的基础上 乘上2，翻转后补1,等价于翻转后的数的基础上 乘上2加1</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List &lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            list.set(i,list.get(i) * <span class="number">2</span>);</span><br><span class="line">            list.add(list.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符匹配-leetcode-T10"><a href="#字符匹配-leetcode-T10" class="headerlink" title="字符匹配 leetcode T10"></a>字符匹配 <code>leetcode T10</code></h3><p><img src="https://cdn.acwing.com/media/article/image/2020/06/09/7416_d13e30f0aa-17362169-1494d2d44bb18bfe.png"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/06/09/7416_d610d808aa-17362169-f12d881c769cc544.png"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/06/08/32343_641a2054a9-QQ%E5%9B%BE%E7%89%8720200601130254.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:p.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="string">&#x27;*&#x27;</span> || (res.length() &gt; <span class="number">0</span> &amp;&amp; res.charAt(res.length() - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        p = res.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(),m = p.length();</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        p = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">10</span>][m + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= m &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;<span class="comment">//当前位应该和下一位看作整体</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (p.charAt(j) == s.charAt(i)) || (p.charAt(j) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    f[i][j] = i != <span class="number">0</span> &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (p.charAt(j - <span class="number">1</span>) == s.charAt(i)) || (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>] || (i != <span class="number">0</span> &amp;&amp; f[i - <span class="number">1</span>][j] &amp;&amp; flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="双指针问题-leetcode-T11"><a href="#双指针问题-leetcode-T11" class="headerlink" title="双指针问题 leetcode T11"></a>双指针问题 <code>leetcode T11</code></h2><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240802180425502.png" alt="image-20240802180425502"></p>
<p>通过证明可以得到结论：<code>i</code>从数组左边开始走，<code>j</code>从数组后面开始走，只要满足哪边小，就将哪边往中间移动，一定会找到最优解。</p>
<p>证明:</p>
<p>设<code>i&#39;</code>为最优解的位置,<code>j&#39;</code>为最优解<code>j</code>的位置；假设<code>i</code>先走到了<code>i&#39;</code>，只需要证明<code>j</code>一定会一直减小直到最优解<code>j</code>处即可。</p>
<p>若假设<code>h[j] &gt; h[i]</code>,此时的<code>h[i&#39;, j]</code>对应的位置一定会比最优解大，所以假设不成立，<code>h[j] &lt; h[i]</code> 此时<code>j</code>向左移动，同理<code>j</code>会一直向左移动，直到到达<code>j</code>位置</p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240802181016545.png" alt="image-20240802181016545"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = n - <span class="number">1</span>; i &lt; j ; ) &#123;</span><br><span class="line">            res = Math.max(res, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="模拟题-leetcode-T12"><a href="#模拟题-leetcode-T12" class="headerlink" title="模拟题 leetcode T12"></a>模拟题 <code>leetcode T12</code></h2><p><img src="C:\Users\Pinguier\AppData\Local\Temp\1722594676.png" alt="1722594676"></p>
<p>将所有单位枚举出来可以发现，采用红色单位可以将所有的整数全部表示成罗马数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] values = &#123;</span><br><span class="line">        <span class="number">1000</span>,</span><br><span class="line">        <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>,</span><br><span class="line">        <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        String [] rep = &#123;</span><br><span class="line">        <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= values[i]) &#123;</span><br><span class="line">                num -= values[i];</span><br><span class="line">                res += rep[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 同理 <code>leetcode T13</code>更简单，只需要将罗马数字对应阿拉伯数字，从前往后枚举字符串：遇到罗马数字小的在大的前的就减去当前罗马数字对应的数值，反之就加即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">            put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">            put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">            put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">            put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">            put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">            put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">            put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; map.get(s.charAt(i)) &lt; map.get(s.charAt(i+<span class="number">1</span>)))</span><br><span class="line">                res -= map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += map.get(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="简单枚举-leetcode-T14"><a href="#简单枚举-leetcode-T14" class="headerlink" title="简单枚举 leetcode T14"></a>简单枚举 <code>leetcode T14</code></h2><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240803183213847.png" alt="image-20240803183213847"></p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>枚举第一个字符串的所有元素，同时枚举后面的子串的对应位置元素，当出现字串该位置和第一个字符串该位置的元素不相等时表示寻找完毕，此题枚举的新意在与第一重循环枚举的是字符串数组<code>strs[0]</code>内部的元素，第二重循环枚举的是字符串数组<code>strs</code>的外重字串，这提示在写for循环的时候不一定直接按照外到内的顺序枚举。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length();i++) &#123;</span><br><span class="line">            <span class="comment">// 枚举第一个字符串中的所有字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 枚举除了第一个字符串以外的其他串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strs.length;j++) &#123;</span><br><span class="line">                <span class="comment">// 当出现第j个串的i位置不等于第一个串或者第j个串当前i位置没有元素时表示最大前缀寻找完毕</span></span><br><span class="line">                <span class="keyword">if</span>(strs[j].length() - <span class="number">1</span> &lt; i || strs[j].charAt(i) != c )</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h2 id="leetcode-T15-三数相加"><a href="#leetcode-T15-三数相加" class="headerlink" title="leetcode T15 三数相加"></a><code>leetcode T15 三数相加</code></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240804190212537.png" alt="image-20240804190212537"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于该题，考虑双指针算法，首先双指针算法必须保证有序。因为枚举三个数,所以可以先固定<code>i</code>,对<code>j</code>和<code>k</code>进行双指针枚举。当<code>i</code>固定以后，会发现满足条件的<code>j</code>和<code>k</code>之间是有约束的，当<code>j</code>往前移动的时候，<code>k</code>一定是向左移动的，这就保证了<code>j</code>和<code>k</code>一共会遍历n个数，因此算法的整体时间复杂度为O(n^2)。对于双指针算法的内部，每次将k向前试探，一直到k去到不满足<code>nums[i] + nums[j] + nums[k] &gt;=0</code> 的位置。对于判重，因为数组的有序的，只需要判断当前元素是否等于上一个元素，详细见代码。</p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240804184943952.png" alt="image-20240804184943952"></p>
<h3 id="代码-："><a href="#代码-：" class="headerlink" title="代码 ："></a>代码 ：</h3><p>c++:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">// 双指针算法先判重</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 先枚举i 固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针算法枚举j和k</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j ++) &#123;</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; k <span class="number">-1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span> )  k--;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>) res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>‘java’:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>,k = nums.length - <span class="number">1</span>; j &lt; k;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;=<span class="number">0</span>) k--;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[k] + nums[j] == <span class="number">0</span>)</span><br><span class="line">                    list.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四数之和-leetcode-T18"><a href="#四数之和-leetcode-T18" class="headerlink" title="四数之和  leetcode T18"></a>四数之和  <code>leetcode T18</code></h3><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240813195545712.png" alt="image-20240813195545712"></p>
<p>此题与三数之和的区别:</p>
<p>1.枚举两重循环，内存两重用双指针进行简化。</p>
<p>2.针对数据报int，判断四数相加时转<code>long</code></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>, u = nums.length - <span class="number">1</span>; k &lt; u;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span>(k &lt; u - <span class="number">1</span> &amp;&amp; (<span class="type">long</span> )nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] &gt;= target) u--;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="type">long</span> )nums[i] + nums[j] + nums[k] + nums[u] == target)</span><br><span class="line">                        list.add(Arrays.asList(nums[i],nums[j],nums[k],nums[u]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归-双指针"><a href="#递归-双指针" class="headerlink" title="递归+双指针"></a>递归+双指针</h3><p><code>leetcode T38</code></p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240909202111070.png" alt="image-20240909202111070"></p>
<p>难点是读懂题意</p>
<p>1 1</p>
<p>2 11</p>
<p>3 21</p>
<p>4 1211</p>
<p>5 111221</p>
<p>题目的基本含义是递归的思想，开始从”1”开始，每次都对一段字符串枚举，采用双指针的方式，将字符串分段，对于每段重复元素用重复元素数量 + 重复元素的形式存到下一个枚举的结果里，依次进行重复 <code>n - 1</code>次，实现第<code>n</code>个外观数列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>; <span class="comment">// 初始字符串为 &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 n - 1 次，因为第一次已经是 &quot;1&quot; 了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 使用 StringBuilder 进行字符串拼接</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 找到连续相同字符的长度</span></span><br><span class="line">                <span class="keyword">while</span> (k &lt; s.length() &amp;&amp; s.charAt(k) == s.charAt(j)) k++;</span><br><span class="line">                <span class="comment">// 拼接当前字符的个数和字符本身</span></span><br><span class="line">OAOAOAOAOAOA                t.append(k - j).append(s.charAt(j));</span><br><span class="line">                <span class="comment">// 移动 j 指针，跳过已经处理过的字符</span></span><br><span class="line">                j = k - <span class="number">1</span>; <span class="comment">// 调整 j，因为外层循环会增加 j</span></span><br><span class="line">            &#125;</span><br><span class="line">OAOAOAOAOA<span class="type">OA</span>            <span class="variable">s</span> <span class="operator">=</span> t.toString(); <span class="comment">// 更新 s 为下一次循环的结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s; <span class="comment">// 返回最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似题目 <code>leetcode T443</code></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 辅助函数：用于反转字符数组中从索引 l 到 r 的部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 当 l 小于 r 时，继续交换元素</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l]; <span class="comment">// 临时保存 s[l] 的值</span></span><br><span class="line">            s[l] = s[r]; <span class="comment">// 将 s[r] 的值赋给 s[l]</span></span><br><span class="line">            s[r] = temp; <span class="comment">// 将临时保存的值赋给 s[r]</span></span><br><span class="line">            l++; <span class="comment">// 左边指针向右移动</span></span><br><span class="line">            r--; <span class="comment">// 右边指针向左移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数：用于压缩字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// k 用于追踪压缩后字符数组的写入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123; <span class="comment">// 遍历整个字符数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算当前字符的连续重复个数</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; chars.length &amp;&amp; chars[i] == chars[j]) j++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> j - i; <span class="comment">// len 表示当前字符连续出现的次数</span></span><br><span class="line">            chars[k++] = chars[i]; <span class="comment">// 将当前字符存入压缩数组</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符的重复次数大于 1，则需要将重复次数添加到数组中</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> k; <span class="comment">// t 用于记录数字开始写入的位置</span></span><br><span class="line">                <span class="comment">// 将重复次数按位拆分，逐位存入数组</span></span><br><span class="line">                <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    chars[k++] = (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + len % <span class="number">10</span>); <span class="comment">// 将数字转换为字符并写入数组</span></span><br><span class="line">                    len /= <span class="number">10</span>; <span class="comment">// 继续处理下一位</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 因为是从低位开始存的数字，需要将其反转，恢复正确的顺序</span></span><br><span class="line">                reverse(chars, t, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i = j - <span class="number">1</span>; <span class="comment">// 更新 i 的位置，跳过已经处理过的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k; <span class="comment">// 返回压缩后的字符数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="双指针解决链表问题"><a href="#双指针解决链表问题" class="headerlink" title="双指针解决链表问题"></a>双指针解决链表问题</h3><h4 id="单链表中倒数第n个节点"><a href="#单链表中倒数第n个节点" class="headerlink" title="单链表中倒数第n个节点"></a>单链表中倒数第n个节点</h4><p>对于单链表，倒数第n个节点，需要找到倒L数第n+1个节点，通过该节点的next指针访问倒数第n个节点。假设整个链表的长度是L,则倒数第n+1个节点对应从头节点开始移动的次数是<code>L - (n + 1)</code>次。因此，如果采用双指针算法的话，定义<code>first</code>和<code>second</code>两个指针先指向头节点，然后让<code>first</code>指针先移动n次；然后这时候让两个指针同时移动，一直到<code>first</code>指针移动到整个单链表的结尾时，此时<code>second</code>指针指向的下一个节点即为倒数第n个节点。(因为此时<code>first</code>指针移动的距离为 <code>L - (n + 1)</code>)</p>
<p><img src="https://labuladong.online/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/1.jpeg" alt="img"></p>
<p><img src="https://labuladong.online/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/2.jpeg" alt="img"></p>
<p><img src="https://labuladong.online/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/3.jpeg" alt="img"></p>
<h4 id="leetcode-T19"><a href="#leetcode-T19" class="headerlink" title="leetcode T19"></a><code>leetcode T19</code></h4><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240813210127273.png" alt="image-20240813210127273"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 这里让快慢指针分别指向头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 先让快指针移动n步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) first = first.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时移动 当快指针刚好指向整个链表的最后一个元素(非空)时，两个指针相差n步 假设整个链表的长度是L 则移动步数为 L - (n + 1)</span></span><br><span class="line">        <span class="comment">// 此时慢指针恰好走到了倒数第n个节点的前一个节点(倒数第n个节点前一个节点为倒数第n+1 即正数L - (n + 1)个节点)</span></span><br><span class="line">        <span class="keyword">while</span>(first.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除当前节点</span></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-多个单链表的合并问题"><a href="#3-多个单链表的合并问题" class="headerlink" title="3.多个单链表的合并问题"></a>3.多个单链表的合并问题</h4><p>与两个链表的合并相似，只需要每次找到k个链表中最小的节点，把<code>p</code>指向该最小的节点，然后将该链表后移，再重复上述操作即可。</p>
<p>对于寻找多个链表的头节点的最小值，考虑使用优先队列维护(小根堆),因为维护的是链表元素，因此需要<code>自定义排序</code>。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>每次将<code>k</code>个队列的头节点用优先队列维护，每次操作时，从小根堆取出堆顶元素，维护小根堆，时间复杂度是O(<code>logk</code>),链表的长度为<code>n</code>,所以一共的时间复杂度为O<code>n</code>(<code>logk</code>)</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义排序优先队列 从小到大 实现小根堆</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;ListNode&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将k个列表的头节点加入到优先队列中 这样可以找到k个元素中的最小的头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">//当队列不为空</span></span><br><span class="line">        <span class="keyword">while</span>(q.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将队列中最小的头节点取出来并将p指针指向最小的t节点 此时将t出队</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            p = p.next = t;</span><br><span class="line">            <span class="comment">// t指向下一个节点 表示当前的链表后移</span></span><br><span class="line">            t = t.next;</span><br><span class="line">            <span class="comment">// 当t所在的链表还存在时将该链表的头指针入队</span></span><br><span class="line">            <span class="keyword">if</span>(t != <span class="literal">null</span>) q.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-k个元素每一组的单链表翻转问题"><a href="#4-k个元素每一组的单链表翻转问题" class="headerlink" title="4.k个元素每一组的单链表翻转问题"></a><code>4</code>.k个元素每一组的单链表翻转问题</h4><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p><img src="https://cdn.acwing.com/media/article/image/2020/06/20/7416_5fe9a2e4b2-2020-06-20_141447.jpg"></p>
<h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><p>对于该问题，画图考虑，应该分为三步：</p>
<p>1.将k个元素内部的边倒序(k-1次)</p>
<p>2.将一开始在k个元素的头部的元素的边指向第k+1个元素</p>
<p>3.将头指针指向一开始在k个元素的尾部的元素的边(这一步的作用是建立了虚拟头节点以后，可以通过虚拟头节点顺序遍历整个链表从而返回答案)</p>
<h4 id="代码-：-1"><a href="#代码-：-1" class="headerlink" title="代码 ："></a>代码 ：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">//]: # (打卡模板，上面预览按钮可以展示预览效果 ^^)</span></span><br><span class="line">```</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历整个链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy; ;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否有k个元素</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; q !=<span class="literal">null</span>; i++) q= q.next;</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内部翻转倒序边 k-1条</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> p.next, b = a.next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k-<span class="number">1</span>;i++) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">c</span> <span class="operator">=</span> b.next;</span><br><span class="line">                b.next = a;</span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">c</span> <span class="operator">=</span> p.next;</span><br><span class="line">            <span class="comment">// 翻转前面的元素的指向</span></span><br><span class="line">            p.next = a;</span><br><span class="line">            <span class="comment">// 翻转后面的元素的指向</span></span><br><span class="line">            c.next = b;</span><br><span class="line">            <span class="comment">// 更新p的位置 继续做后面元素的遍历</span></span><br><span class="line">            p = c;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="括号序列问题"><a href="#括号序列问题" class="headerlink" title="括号序列问题"></a>括号序列问题</h3><h4 id="1-括号匹配-考虑栈"><a href="#1-括号匹配-考虑栈" class="headerlink" title="1.括号匹配 考虑栈"></a>1.括号匹配 考虑栈</h4><h4 id="leetcode-T20"><a href="#leetcode-T20" class="headerlink" title="leetcode T20"></a><code>leetcode T20</code></h4><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240814200842810.png" alt="image-20240814200842810"></p>
<p>本题采用栈的方式进行模拟括号匹配的过程，遍历整个字符串，当为左序列时添加进栈，为有序列时需要判断是否与当前栈顶元素匹配：若匹配则弹出栈顶元素，否则整个字符串不匹配。若最后栈不为空，则表示不匹配。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="string">&#x27;(&#x27;</span> || t == <span class="string">&#x27;&#123;&#x27;</span> || t == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stk.add(t);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(stk.peek() == <span class="string">&#x27;(&#x27;</span> &amp;&amp; t == <span class="string">&#x27;)&#x27;</span>) stk.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(stk.peek() == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; t == <span class="string">&#x27;&#125;&#x27;</span>) stk.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(stk.peek() == <span class="string">&#x27;[&#x27;</span> &amp;&amp; t == <span class="string">&#x27;]&#x27;</span>) stk.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-括号生成-考虑dfs"><a href="#2-括号生成-考虑dfs" class="headerlink" title="2.括号生成 考虑dfs"></a>2.括号生成 考虑<code>dfs</code></h4><h4 id="leetcode-T22"><a href="#leetcode-T22" class="headerlink" title="leetcode T22"></a><code>leetcode T22</code></h4><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240814204558102.png" alt="image-20240814204558102"></p>
<p>对于只有小括号匹配的问题，考虑合法方案时的充要条件：</p>
<p><code>l</code>表示<code>(</code>的数量， <code>r</code>表示<code>)</code>的数量  <code>n</code>为括号对数</p>
<ol>
<li>任意前缀中 <code>l</code> &gt; <code>r</code></li>
<li>最后的方案里 <code>l</code> &#x3D; <code>r</code></li>
</ol>
<p>因为本题中左右括号数量一定相等，因此只需要满足条件1即可。</p>
<p>即在任意前缀中：<code>l</code> &lt; <code>n</code>  &amp;&amp; <code>r</code> &lt; <code>l</code></p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>直接生成合法的序列一定满足右括号的个数总是小于等于左括号的个数，是一个典型的卡特兰数问题，卡特兰数的时间复杂度是</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>O<span class="keyword">\left</span>(<span class="keyword">\frac</span>&#123;Cn<span class="built_in">^</span>&#123;2n&#125;&#125;&#123;n+1&#125;<span class="keyword">\right</span>)<span class="built_in">$</span></span><br></pre></td></tr></table></figure>



<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> n, String path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l == n &amp;&amp; r == n) &#123;</span><br><span class="line">            ans.add(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; n) dfs(l + <span class="number">1</span>, r, n, path + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r) dfs(l, r + <span class="number">1</span>, n, path + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,n,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a><code>kmp</code>算法</h2><h3 id="leetcode-T28"><a href="#leetcode-T28" class="headerlink" title="leetcode T28"></a><code>leetcode T28</code></h3><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240904150149580.png" alt="image-20240904150149580"></p>
<h4 id="一般kmp算法下标从1开始更加方便"><a href="#一般kmp算法下标从1开始更加方便" class="headerlink" title="一般kmp算法下标从1开始更加方便"></a>一般<code>kmp</code>算法下标从1开始更加方便</h4><p><img src="C:\Users\Pinguier\AppData\Local\Temp\1725433950(1).png" alt="1725433950(1)"></p>
<p>如图，一定要弄清楚<code>next[i]</code>的含义：所有的p[1~i]的相等的前缀和后缀中长度的最大值。</p>
<p><code>p[1,j] = p[i-j+1,i]</code></p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(needle.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">char</span> [] s = (<span class="string">&quot; &quot;</span> + haystack).toCharArray();</span><br><span class="line">        <span class="type">char</span> [] p = (<span class="string">&quot; &quot;</span> + needle).toCharArray();</span><br><span class="line">        <span class="type">int</span> [] ne = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造ne数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j != <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            ne[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j != <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">                j = ne[j];</span><br><span class="line">                <span class="keyword">return</span> i - m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h3><p>有单调性一定可以二分 没有单调性也有可能可以二分</p>
<p>二分模板一共有两个，分别适用于不同情况。<br>算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l &#x3D; r时，我们就找到了目标值。</p>
<p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240905104433075.png" alt="image-20240905104433075"></p>
<h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r &#x3D; mid或者l &#x3D; mid + 1;，计算mid时不需要加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r &#x3D; mid - 1或者l &#x3D; mid;，此时为了防止死循环，计算mid时需要加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>题目参考<code>leetcode</code> T33-T35</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] results = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] == target) &#123;</span><br><span class="line">            results[<span class="number">0</span>] = r;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] == target) &#123;</span><br><span class="line">                results[<span class="number">1</span>] = r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="dfs算法-常考！！！"><a href="#dfs算法-常考！！！" class="headerlink" title="dfs算法    	常考！！！"></a><code>dfs</code>算法    	常考！！！</h3><h4 id="题目1-leetcode-T37-解数独问题"><a href="#题目1-leetcode-T37-解数独问题" class="headerlink" title="题目1 leetcode T37 解数独问题"></a>题目1 <code>leetcode T37 解数独问题</code></h4><p><img src="C:\Users\Pinguier\AppData\Roaming\Typora\typora-user-images\image-20240906220514556.png" alt="image-20240906220514556"></p>
<h5 id="分析限制："><a href="#分析限制：" class="headerlink" title="分析限制："></a>分析限制：</h5><ol>
<li><p>数字 <code>1-9</code> 在每一行只能出现一次。</p>
</li>
<li><p>数字 <code>1-9</code> 在每一列只能出现一次。</p>
</li>
<li><p>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</p>
</li>
</ol>
<p>由于上述三条限制存在，在整个表盘中填写数字是需要考虑：</p>
<p>​	1.当前位置元素是<code>.</code>时，说明当前位置没有元素，填入满足上述限制的1-9数字</p>
<p>​	2.当前元素不是<code>.</code>时，说明一开始当前位置就存在元素，那么需要将当前元素的值与上述限制相结合，换句话说也就是初始化的时候要将当前元素的值加入到限制当中。</p>
<p>对于上述限制，考虑引入判重数组，<code>rows[i][t] cols[i][t] ceils[i][j][t]</code> 对于行和列判重，第一维度表示当前行&#x2F;列，对于<code>3X3</code>的宫内判重，前两维表示当前宫。</p>
<p>关于<code>dfs</code>算法的具体回溯，因为本题只需要返回一个答案，并且是在原数组上进行修改，因此采用dfs函数具有返回值，这样可以在回溯的时候减少回溯次数，详情见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 设置全局变量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">      <span class="type">boolean</span>[][] rows = <span class="keyword">new</span> <span class="title class_">boolean</span>[N][N];</span><br><span class="line">      <span class="type">boolean</span>[][] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[N][N];</span><br><span class="line">      <span class="type">boolean</span>[][][] ceils = <span class="keyword">new</span> <span class="title class_">boolean</span>[N / <span class="number">3</span>][N / <span class="number">3</span>][N];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == N) &#123;x++; y = <span class="number">0</span>;&#125; <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">if</span>(x == N) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// dfs完毕返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先处理已经填好的元素 该位置有元素则遍历下一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该位置没有元素 填充满足条件的数字1-9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!rows[x][i] &amp;&amp; !cols[y][i] &amp;&amp; !ceils[x / <span class="number">3</span>][y / <span class="number">3</span>][i]) &#123;</span><br><span class="line">                board[x][y] = (<span class="type">char</span>)(i + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                rows[x][i] = cols[y][i] = ceils[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 下一个位置可以填充继续遍历 则不需要回溯</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(board, x, y + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//  下一个位置搜索不对则回溯 恢复现场</span></span><br><span class="line">                board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                rows[x][i] = cols[y][i] = ceils[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化判重数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    rows[i][t] = cols[j][t] = ceils[i / <span class="number">3</span>][j / <span class="number">3</span>][t] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>

                
                </div>
            </div>
        </div>
    </div>
</div>

</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
